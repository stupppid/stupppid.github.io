{"version":3,"sources":["../../AppData/Roaming/npm/node_modules/parcel/src/builtins/bundle-url.js","../../AppData/Roaming/npm/node_modules/parcel/src/builtins/bundle-loader.js","node_modules/three/examples/js/controls/OrbitControls.js","node_modules/three/examples/js/loaders/GLTFLoader.js","pages/pingpong/index.js","../../AppData/Roaming/npm/node_modules/parcel/src/builtins/loaders/browser/js-loader.js"],"names":["bundleURL","getBundleURLCached","getBundleURL","Error","err","matches","stack","match","getBaseURL","url","replace","exports","require","loadBundlesLazy","bundles","Array","isArray","id","length","Promise","resolve","code","LazyPromise","reject","loadBundles","slice","then","all","map","loadBundle","bundleLoaders","registerBundleLoader","type","loader","module","load","register","bundle","substring","lastIndexOf","toLowerCase","bundleLoader","resolved","catch","e","executor","promise","prototype","onSuccess","onError","THREE","Ammo","scene","camera","renderer","dynamicsWorld","clock","transform","racket","p2p","rigidBodies","initPhysics","config","btDefaultCollisionConfiguration","dispather","btCollisionDispatcher","broadphase","btDbvtBroadphase","solver","btSequentialImpulseConstraintSolver","btDiscreteDynamicsWorld","setGravity","btVector3","updatePhysics","deltaTime","enableFeedback","stepSimulation","i","il","objThree","ms","userData","physicsBody","getMotionState","getWorldTransform","p","getOrigin","q","getRotation","position","set","x","y","z","quaternion","w","addRigidBody","shape","mass","localInertia","bodyInfo","pos","quat","setMargin","t","btTransform","setIdentity","setOrigin","setRotation","btQuaternion","btDefaultMotionState","calculateLocalInertia","rbInfo","btRigidBodyConstructionInfo","body","btRigidBody","physicsBodys","push","charAt","toUpperCase","substr","createHouse","width","height","h","ground","Mesh","BoxGeometry","MeshPhongMaterial","color","side","DoubleSide","castShadow","receiveShadow","friction","restitution","infos","btBoxShape","Vector3","add","createObjects","pLight","PointLight","p2","clone","GLTFLoader","obj","table","children","tableHeight","xhr","console","log","error","radius","ball","SphereGeometry","MeshLambertMaterial","ballShape","btSphereShape","rollingFriction","initWorld","window","Scene","antialias","background","Color","light","AmbientLight","PerspectiveCamera","innerWidth","innerHeight","lookAt","WebGLRenderer","setPixelRatio","devicePixelRatio","setSize","shadowMap","enabled","render","controls","OrbitControls","target","update","document","getElementById","appendChild","domElement","addEventListener","bd","origin","pt","Object3D","keyCode","removeConstraint","btPoint2PointConstraint","addConstraint","stopFlag","animate","getDelta","requestAnimationFrame","flagArr","index","delay","setTimeout","init","every","value","loaded","beforeEnter","Clock","beforeLeave","script","createElement","async","charset","src","onerror","onload","getElementsByTagName"],"mappings":"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","file":"pingpong.6d1e9ac5.js","sourceRoot":"..","sourcesContent":["var bundleURL = null;\nfunction getBundleURLCached() {\n  if (!bundleURL) {\n    bundleURL = getBundleURL();\n  }\n\n  return bundleURL;\n}\n\nfunction getBundleURL() {\n  // Attempt to find the URL of the current script and use that as the base URL\n  try {\n    throw new Error;\n  } catch (err) {\n    var matches = ('' + err.stack).match(/(https?|file|ftp|chrome-extension|moz-extension):\\/\\/[^)\\n]+/g);\n    if (matches) {\n      return getBaseURL(matches[0]);\n    }\n  }\n\n  return '/';\n}\n\nfunction getBaseURL(url) {\n  return ('' + url).replace(/^((?:https?|file|ftp|chrome-extension|moz-extension):\\/\\/.+)\\/[^/]+$/, '$1') + '/';\n}\n\nexports.getBundleURL = getBundleURLCached;\nexports.getBaseURL = getBaseURL;\n","var getBundleURL = require('./bundle-url').getBundleURL;\n\nfunction loadBundlesLazy(bundles) {\n  if (!Array.isArray(bundles)) {\n    bundles = [bundles]\n  }\n\n  var id = bundles[bundles.length - 1];\n\n  try {\n    return Promise.resolve(require(id));\n  } catch (err) {\n    if (err.code === 'MODULE_NOT_FOUND') {\n      return new LazyPromise(function (resolve, reject) {\n        loadBundles(bundles.slice(0, -1))\n          .then(function () {\n            return require(id);\n          })\n          .then(resolve, reject);\n      });\n    }\n\n    throw err;\n  }\n}\n\nfunction loadBundles(bundles) {\n  return Promise.all(bundles.map(loadBundle));\n}\n\nvar bundleLoaders = {};\nfunction registerBundleLoader(type, loader) {\n  bundleLoaders[type] = loader;\n}\n\nmodule.exports = exports = loadBundlesLazy;\nexports.load = loadBundles;\nexports.register = registerBundleLoader;\n\nvar bundles = {};\nfunction loadBundle(bundle) {\n  var id;\n  if (Array.isArray(bundle)) {\n    id = bundle[1];\n    bundle = bundle[0];\n  }\n\n  if (bundles[bundle]) {\n    return bundles[bundle];\n  }\n\n  var type = (bundle.substring(bundle.lastIndexOf('.') + 1, bundle.length) || bundle).toLowerCase();\n  var bundleLoader = bundleLoaders[type];\n  if (bundleLoader) {\n    return bundles[bundle] = bundleLoader(getBundleURL() + bundle)\n      .then(function (resolved) {\n        if (resolved) {\n          module.bundle.register(id, resolved);\n        }\n\n        return resolved;\n      }).catch(function(e) {\n        delete bundles[bundle];\n        \n        throw e;\n      });\n  }\n}\n\nfunction LazyPromise(executor) {\n  this.executor = executor;\n  this.promise = null;\n}\n\nLazyPromise.prototype.then = function (onSuccess, onError) {\n  if (this.promise === null) this.promise = new Promise(this.executor)\n  return this.promise.then(onSuccess, onError)\n};\n\nLazyPromise.prototype.catch = function (onError) {\n  if (this.promise === null) this.promise = new Promise(this.executor)\n  return this.promise.catch(onError)\n};\n","/**\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author erich666 / http://erichaines.com\n */\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one-finger move\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move\n\nTHREE.OrbitControls = function ( object, domElement ) {\n\n\tthis.object = object;\n\n\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\n\n\t// Set to false to disable this control\n\tthis.enabled = true;\n\n\t// \"target\" sets the location of focus, where the object orbits around\n\tthis.target = new THREE.Vector3();\n\n\t// How far you can dolly in and out ( PerspectiveCamera only )\n\tthis.minDistance = 0;\n\tthis.maxDistance = Infinity;\n\n\t// How far you can zoom in and out ( OrthographicCamera only )\n\tthis.minZoom = 0;\n\tthis.maxZoom = Infinity;\n\n\t// How far you can orbit vertically, upper and lower limits.\n\t// Range is 0 to Math.PI radians.\n\tthis.minPolarAngle = 0; // radians\n\tthis.maxPolarAngle = Math.PI; // radians\n\n\t// How far you can orbit horizontally, upper and lower limits.\n\t// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n\tthis.minAzimuthAngle = - Infinity; // radians\n\tthis.maxAzimuthAngle = Infinity; // radians\n\n\t// Set to true to enable damping (inertia)\n\t// If damping is enabled, you must call controls.update() in your animation loop\n\tthis.enableDamping = false;\n\tthis.dampingFactor = 0.25;\n\n\t// This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n\t// Set to false to disable zooming\n\tthis.enableZoom = true;\n\tthis.zoomSpeed = 1.0;\n\n\t// Set to false to disable rotating\n\tthis.enableRotate = true;\n\tthis.rotateSpeed = 1.0;\n\n\t// Set to false to disable panning\n\tthis.enablePan = true;\n\tthis.panSpeed = 1.0;\n\tthis.screenSpacePanning = false; // if true, pan in screen-space\n\tthis.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\n\n\t// Set to true to automatically rotate around the target\n\t// If auto-rotate is enabled, you must call controls.update() in your animation loop\n\tthis.autoRotate = false;\n\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n\t// Set to false to disable use of the keys\n\tthis.enableKeys = true;\n\n\t// The four arrow keys\n\tthis.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\n\n\t// Mouse buttons\n\tthis.mouseButtons = { LEFT: THREE.MOUSE.LEFT, MIDDLE: THREE.MOUSE.MIDDLE, RIGHT: THREE.MOUSE.RIGHT };\n\n\t// for reset\n\tthis.target0 = this.target.clone();\n\tthis.position0 = this.object.position.clone();\n\tthis.zoom0 = this.object.zoom;\n\n\t//\n\t// public methods\n\t//\n\n\tthis.getPolarAngle = function () {\n\n\t\treturn spherical.phi;\n\n\t};\n\n\tthis.getAzimuthalAngle = function () {\n\n\t\treturn spherical.theta;\n\n\t};\n\n\tthis.saveState = function () {\n\n\t\tscope.target0.copy( scope.target );\n\t\tscope.position0.copy( scope.object.position );\n\t\tscope.zoom0 = scope.object.zoom;\n\n\t};\n\n\tthis.reset = function () {\n\n\t\tscope.target.copy( scope.target0 );\n\t\tscope.object.position.copy( scope.position0 );\n\t\tscope.object.zoom = scope.zoom0;\n\n\t\tscope.object.updateProjectionMatrix();\n\t\tscope.dispatchEvent( changeEvent );\n\n\t\tscope.update();\n\n\t\tstate = STATE.NONE;\n\n\t};\n\n\t// this method is exposed, but perhaps it would be better if we can make it private...\n\tthis.update = function () {\n\n\t\tvar offset = new THREE.Vector3();\n\n\t\t// so camera.up is the orbit axis\n\t\tvar quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );\n\t\tvar quatInverse = quat.clone().inverse();\n\n\t\tvar lastPosition = new THREE.Vector3();\n\t\tvar lastQuaternion = new THREE.Quaternion();\n\n\t\treturn function update() {\n\n\t\t\tvar position = scope.object.position;\n\n\t\t\toffset.copy( position ).sub( scope.target );\n\n\t\t\t// rotate offset to \"y-axis-is-up\" space\n\t\t\toffset.applyQuaternion( quat );\n\n\t\t\t// angle from z-axis around y-axis\n\t\t\tspherical.setFromVector3( offset );\n\n\t\t\tif ( scope.autoRotate && state === STATE.NONE ) {\n\n\t\t\t\trotateLeft( getAutoRotationAngle() );\n\n\t\t\t}\n\n\t\t\tspherical.theta += sphericalDelta.theta;\n\t\t\tspherical.phi += sphericalDelta.phi;\n\n\t\t\t// restrict theta to be between desired limits\n\t\t\tspherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );\n\n\t\t\t// restrict phi to be between desired limits\n\t\t\tspherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );\n\n\t\t\tspherical.makeSafe();\n\n\n\t\t\tspherical.radius *= scale;\n\n\t\t\t// restrict radius to be between desired limits\n\t\t\tspherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );\n\n\t\t\t// move target to panned location\n\t\t\tscope.target.add( panOffset );\n\n\t\t\toffset.setFromSpherical( spherical );\n\n\t\t\t// rotate offset back to \"camera-up-vector-is-up\" space\n\t\t\toffset.applyQuaternion( quatInverse );\n\n\t\t\tposition.copy( scope.target ).add( offset );\n\n\t\t\tscope.object.lookAt( scope.target );\n\n\t\t\tif ( scope.enableDamping === true ) {\n\n\t\t\t\tsphericalDelta.theta *= ( 1 - scope.dampingFactor );\n\t\t\t\tsphericalDelta.phi *= ( 1 - scope.dampingFactor );\n\n\t\t\t\tpanOffset.multiplyScalar( 1 - scope.dampingFactor );\n\n\t\t\t} else {\n\n\t\t\t\tsphericalDelta.set( 0, 0, 0 );\n\n\t\t\t\tpanOffset.set( 0, 0, 0 );\n\n\t\t\t}\n\n\t\t\tscale = 1;\n\n\t\t\t// update condition is:\n\t\t\t// min(camera displacement, camera rotation in radians)^2 > EPS\n\t\t\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n\t\t\tif ( zoomChanged ||\n\t\t\t\tlastPosition.distanceToSquared( scope.object.position ) > EPS ||\n\t\t\t\t8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {\n\n\t\t\t\tscope.dispatchEvent( changeEvent );\n\n\t\t\t\tlastPosition.copy( scope.object.position );\n\t\t\t\tlastQuaternion.copy( scope.object.quaternion );\n\t\t\t\tzoomChanged = false;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t};\n\n\t}();\n\n\tthis.dispose = function () {\n\n\t\tscope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );\n\t\tscope.domElement.removeEventListener( 'mousedown', onMouseDown, false );\n\t\tscope.domElement.removeEventListener( 'wheel', onMouseWheel, false );\n\n\t\tscope.domElement.removeEventListener( 'touchstart', onTouchStart, false );\n\t\tscope.domElement.removeEventListener( 'touchend', onTouchEnd, false );\n\t\tscope.domElement.removeEventListener( 'touchmove', onTouchMove, false );\n\n\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\n\t\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\n\n\t\twindow.removeEventListener( 'keydown', onKeyDown, false );\n\n\t\t//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n\n\t};\n\n\t//\n\t// internals\n\t//\n\n\tvar scope = this;\n\n\tvar changeEvent = { type: 'change' };\n\tvar startEvent = { type: 'start' };\n\tvar endEvent = { type: 'end' };\n\n\tvar STATE = { NONE: - 1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY_PAN: 4 };\n\n\tvar state = STATE.NONE;\n\n\tvar EPS = 0.000001;\n\n\t// current position in spherical coordinates\n\tvar spherical = new THREE.Spherical();\n\tvar sphericalDelta = new THREE.Spherical();\n\n\tvar scale = 1;\n\tvar panOffset = new THREE.Vector3();\n\tvar zoomChanged = false;\n\n\tvar rotateStart = new THREE.Vector2();\n\tvar rotateEnd = new THREE.Vector2();\n\tvar rotateDelta = new THREE.Vector2();\n\n\tvar panStart = new THREE.Vector2();\n\tvar panEnd = new THREE.Vector2();\n\tvar panDelta = new THREE.Vector2();\n\n\tvar dollyStart = new THREE.Vector2();\n\tvar dollyEnd = new THREE.Vector2();\n\tvar dollyDelta = new THREE.Vector2();\n\n\tfunction getAutoRotationAngle() {\n\n\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n\t}\n\n\tfunction getZoomScale() {\n\n\t\treturn Math.pow( 0.95, scope.zoomSpeed );\n\n\t}\n\n\tfunction rotateLeft( angle ) {\n\n\t\tsphericalDelta.theta -= angle;\n\n\t}\n\n\tfunction rotateUp( angle ) {\n\n\t\tsphericalDelta.phi -= angle;\n\n\t}\n\n\tvar panLeft = function () {\n\n\t\tvar v = new THREE.Vector3();\n\n\t\treturn function panLeft( distance, objectMatrix ) {\n\n\t\t\tv.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix\n\t\t\tv.multiplyScalar( - distance );\n\n\t\t\tpanOffset.add( v );\n\n\t\t};\n\n\t}();\n\n\tvar panUp = function () {\n\n\t\tvar v = new THREE.Vector3();\n\n\t\treturn function panUp( distance, objectMatrix ) {\n\n\t\t\tif ( scope.screenSpacePanning === true ) {\n\n\t\t\t\tv.setFromMatrixColumn( objectMatrix, 1 );\n\n\t\t\t} else {\n\n\t\t\t\tv.setFromMatrixColumn( objectMatrix, 0 );\n\t\t\t\tv.crossVectors( scope.object.up, v );\n\n\t\t\t}\n\n\t\t\tv.multiplyScalar( distance );\n\n\t\t\tpanOffset.add( v );\n\n\t\t};\n\n\t}();\n\n\t// deltaX and deltaY are in pixels; right and down are positive\n\tvar pan = function () {\n\n\t\tvar offset = new THREE.Vector3();\n\n\t\treturn function pan( deltaX, deltaY ) {\n\n\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\t\tif ( scope.object.isPerspectiveCamera ) {\n\n\t\t\t\t// perspective\n\t\t\t\tvar position = scope.object.position;\n\t\t\t\toffset.copy( position ).sub( scope.target );\n\t\t\t\tvar targetDistance = offset.length();\n\n\t\t\t\t// half of the fov is center to top of screen\n\t\t\t\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\n\n\t\t\t\t// we use only clientHeight here so aspect ratio does not distort speed\n\t\t\t\tpanLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );\n\t\t\t\tpanUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );\n\n\t\t\t} else if ( scope.object.isOrthographicCamera ) {\n\n\t\t\t\t// orthographic\n\t\t\t\tpanLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );\n\t\t\t\tpanUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );\n\n\t\t\t} else {\n\n\t\t\t\t// camera neither orthographic nor perspective\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\n\t\t\t\tscope.enablePan = false;\n\n\t\t\t}\n\n\t\t};\n\n\t}();\n\n\tfunction dollyIn( dollyScale ) {\n\n\t\tif ( scope.object.isPerspectiveCamera ) {\n\n\t\t\tscale /= dollyScale;\n\n\t\t} else if ( scope.object.isOrthographicCamera ) {\n\n\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );\n\t\t\tscope.object.updateProjectionMatrix();\n\t\t\tzoomChanged = true;\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\tscope.enableZoom = false;\n\n\t\t}\n\n\t}\n\n\tfunction dollyOut( dollyScale ) {\n\n\t\tif ( scope.object.isPerspectiveCamera ) {\n\n\t\t\tscale *= dollyScale;\n\n\t\t} else if ( scope.object.isOrthographicCamera ) {\n\n\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );\n\t\t\tscope.object.updateProjectionMatrix();\n\t\t\tzoomChanged = true;\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\tscope.enableZoom = false;\n\n\t\t}\n\n\t}\n\n\t//\n\t// event callbacks - update the object state\n\t//\n\n\tfunction handleMouseDownRotate( event ) {\n\n\t\t//console.log( 'handleMouseDownRotate' );\n\n\t\trotateStart.set( event.clientX, event.clientY );\n\n\t}\n\n\tfunction handleMouseDownDolly( event ) {\n\n\t\t//console.log( 'handleMouseDownDolly' );\n\n\t\tdollyStart.set( event.clientX, event.clientY );\n\n\t}\n\n\tfunction handleMouseDownPan( event ) {\n\n\t\t//console.log( 'handleMouseDownPan' );\n\n\t\tpanStart.set( event.clientX, event.clientY );\n\n\t}\n\n\tfunction handleMouseMoveRotate( event ) {\n\n\t\t//console.log( 'handleMouseMoveRotate' );\n\n\t\trotateEnd.set( event.clientX, event.clientY );\n\n\t\trotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );\n\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height\n\n\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );\n\n\t\trotateStart.copy( rotateEnd );\n\n\t\tscope.update();\n\n\t}\n\n\tfunction handleMouseMoveDolly( event ) {\n\n\t\t//console.log( 'handleMouseMoveDolly' );\n\n\t\tdollyEnd.set( event.clientX, event.clientY );\n\n\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\tdollyIn( getZoomScale() );\n\n\t\t} else if ( dollyDelta.y < 0 ) {\n\n\t\t\tdollyOut( getZoomScale() );\n\n\t\t}\n\n\t\tdollyStart.copy( dollyEnd );\n\n\t\tscope.update();\n\n\t}\n\n\tfunction handleMouseMovePan( event ) {\n\n\t\t//console.log( 'handleMouseMovePan' );\n\n\t\tpanEnd.set( event.clientX, event.clientY );\n\n\t\tpanDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );\n\n\t\tpan( panDelta.x, panDelta.y );\n\n\t\tpanStart.copy( panEnd );\n\n\t\tscope.update();\n\n\t}\n\n\tfunction handleMouseUp( event ) {\n\n\t\t// console.log( 'handleMouseUp' );\n\n\t}\n\n\tfunction handleMouseWheel( event ) {\n\n\t\t// console.log( 'handleMouseWheel' );\n\n\t\tif ( event.deltaY < 0 ) {\n\n\t\t\tdollyOut( getZoomScale() );\n\n\t\t} else if ( event.deltaY > 0 ) {\n\n\t\t\tdollyIn( getZoomScale() );\n\n\t\t}\n\n\t\tscope.update();\n\n\t}\n\n\tfunction handleKeyDown( event ) {\n\n\t\t// console.log( 'handleKeyDown' );\n\n\t\tvar needsUpdate = false;\n\n\t\tswitch ( event.keyCode ) {\n\n\t\t\tcase scope.keys.UP:\n\t\t\t\tpan( 0, scope.keyPanSpeed );\n\t\t\t\tneedsUpdate = true;\n\t\t\t\tbreak;\n\n\t\t\tcase scope.keys.BOTTOM:\n\t\t\t\tpan( 0, - scope.keyPanSpeed );\n\t\t\t\tneedsUpdate = true;\n\t\t\t\tbreak;\n\n\t\t\tcase scope.keys.LEFT:\n\t\t\t\tpan( scope.keyPanSpeed, 0 );\n\t\t\t\tneedsUpdate = true;\n\t\t\t\tbreak;\n\n\t\t\tcase scope.keys.RIGHT:\n\t\t\t\tpan( - scope.keyPanSpeed, 0 );\n\t\t\t\tneedsUpdate = true;\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( needsUpdate ) {\n\n\t\t\t// prevent the browser from scrolling on cursor keys\n\t\t\tevent.preventDefault();\n\n\t\t\tscope.update();\n\n\t\t}\n\n\n\t}\n\n\tfunction handleTouchStartRotate( event ) {\n\n\t\t//console.log( 'handleTouchStartRotate' );\n\n\t\trotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\n\t}\n\n\tfunction handleTouchStartDollyPan( event ) {\n\n\t\t//console.log( 'handleTouchStartDollyPan' );\n\n\t\tif ( scope.enableZoom ) {\n\n\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\n\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\tdollyStart.set( 0, distance );\n\n\t\t}\n\n\t\tif ( scope.enablePan ) {\n\n\t\t\tvar x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );\n\t\t\tvar y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );\n\n\t\t\tpanStart.set( x, y );\n\n\t\t}\n\n\t}\n\n\tfunction handleTouchMoveRotate( event ) {\n\n\t\t//console.log( 'handleTouchMoveRotate' );\n\n\t\trotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\n\t\trotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );\n\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height\n\n\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );\n\n\t\trotateStart.copy( rotateEnd );\n\n\t\tscope.update();\n\n\t}\n\n\tfunction handleTouchMoveDollyPan( event ) {\n\n\t\t//console.log( 'handleTouchMoveDollyPan' );\n\n\t\tif ( scope.enableZoom ) {\n\n\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\n\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\tdollyEnd.set( 0, distance );\n\n\t\t\tdollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );\n\n\t\t\tdollyIn( dollyDelta.y );\n\n\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t}\n\n\t\tif ( scope.enablePan ) {\n\n\t\t\tvar x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );\n\t\t\tvar y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );\n\n\t\t\tpanEnd.set( x, y );\n\n\t\t\tpanDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );\n\n\t\t\tpan( panDelta.x, panDelta.y );\n\n\t\t\tpanStart.copy( panEnd );\n\n\t\t}\n\n\t\tscope.update();\n\n\t}\n\n\tfunction handleTouchEnd( event ) {\n\n\t\t//console.log( 'handleTouchEnd' );\n\n\t}\n\n\t//\n\t// event handlers - FSM: listen for events and reset state\n\t//\n\n\tfunction onMouseDown( event ) {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\t// Prevent the browser from scrolling.\n\n\t\tevent.preventDefault();\n\n\t\t// Manually set the focus since calling preventDefault above\n\t\t// prevents the browser from setting it automatically.\n\n\t\tscope.domElement.focus ? scope.domElement.focus() : window.focus();\n\n\t\tswitch ( event.button ) {\n\n\t\t\tcase scope.mouseButtons.LEFT:\n\n\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\thandleMouseDownPan( event );\n\n\t\t\t\t\tstate = STATE.PAN;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\thandleMouseDownRotate( event );\n\n\t\t\t\t\tstate = STATE.ROTATE;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase scope.mouseButtons.MIDDLE:\n\n\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\thandleMouseDownDolly( event );\n\n\t\t\t\tstate = STATE.DOLLY;\n\n\t\t\t\tbreak;\n\n\t\t\tcase scope.mouseButtons.RIGHT:\n\n\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\thandleMouseDownPan( event );\n\n\t\t\t\tstate = STATE.PAN;\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( state !== STATE.NONE ) {\n\n\t\t\tdocument.addEventListener( 'mousemove', onMouseMove, false );\n\t\t\tdocument.addEventListener( 'mouseup', onMouseUp, false );\n\n\t\t\tscope.dispatchEvent( startEvent );\n\n\t\t}\n\n\t}\n\n\tfunction onMouseMove( event ) {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\tevent.preventDefault();\n\n\t\tswitch ( state ) {\n\n\t\t\tcase STATE.ROTATE:\n\n\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\thandleMouseMoveRotate( event );\n\n\t\t\t\tbreak;\n\n\t\t\tcase STATE.DOLLY:\n\n\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\thandleMouseMoveDolly( event );\n\n\t\t\t\tbreak;\n\n\t\t\tcase STATE.PAN:\n\n\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\thandleMouseMovePan( event );\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\tfunction onMouseUp( event ) {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\thandleMouseUp( event );\n\n\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\n\t\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\n\n\t\tscope.dispatchEvent( endEvent );\n\n\t\tstate = STATE.NONE;\n\n\t}\n\n\tfunction onMouseWheel( event ) {\n\n\t\tif ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tscope.dispatchEvent( startEvent );\n\n\t\thandleMouseWheel( event );\n\n\t\tscope.dispatchEvent( endEvent );\n\n\t}\n\n\tfunction onKeyDown( event ) {\n\n\t\tif ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;\n\n\t\thandleKeyDown( event );\n\n\t}\n\n\tfunction onTouchStart( event ) {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\tevent.preventDefault();\n\n\t\tswitch ( event.touches.length ) {\n\n\t\t\tcase 1:\t// one-fingered touch: rotate\n\n\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\thandleTouchStartRotate( event );\n\n\t\t\t\tstate = STATE.TOUCH_ROTATE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\t// two-fingered touch: dolly-pan\n\n\t\t\t\tif ( scope.enableZoom === false && scope.enablePan === false ) return;\n\n\t\t\t\thandleTouchStartDollyPan( event );\n\n\t\t\t\tstate = STATE.TOUCH_DOLLY_PAN;\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t\tif ( state !== STATE.NONE ) {\n\n\t\t\tscope.dispatchEvent( startEvent );\n\n\t\t}\n\n\t}\n\n\tfunction onTouchMove( event ) {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tswitch ( event.touches.length ) {\n\n\t\t\tcase 1: // one-fingered touch: rotate\n\n\t\t\t\tif ( scope.enableRotate === false ) return;\n\t\t\t\tif ( state !== STATE.TOUCH_ROTATE ) return; // is this needed?\n\n\t\t\t\thandleTouchMoveRotate( event );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 2: // two-fingered touch: dolly-pan\n\n\t\t\t\tif ( scope.enableZoom === false && scope.enablePan === false ) return;\n\t\t\t\tif ( state !== STATE.TOUCH_DOLLY_PAN ) return; // is this needed?\n\n\t\t\t\thandleTouchMoveDollyPan( event );\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t}\n\n\tfunction onTouchEnd( event ) {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\thandleTouchEnd( event );\n\n\t\tscope.dispatchEvent( endEvent );\n\n\t\tstate = STATE.NONE;\n\n\t}\n\n\tfunction onContextMenu( event ) {\n\n\t\tif ( scope.enabled === false ) return;\n\n\t\tevent.preventDefault();\n\n\t}\n\n\t//\n\n\tscope.domElement.addEventListener( 'contextmenu', onContextMenu, false );\n\n\tscope.domElement.addEventListener( 'mousedown', onMouseDown, false );\n\tscope.domElement.addEventListener( 'wheel', onMouseWheel, false );\n\n\tscope.domElement.addEventListener( 'touchstart', onTouchStart, false );\n\tscope.domElement.addEventListener( 'touchend', onTouchEnd, false );\n\tscope.domElement.addEventListener( 'touchmove', onTouchMove, false );\n\n\twindow.addEventListener( 'keydown', onKeyDown, false );\n\n\t// force an update at start\n\n\tthis.update();\n\n};\n\nTHREE.OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );\nTHREE.OrbitControls.prototype.constructor = THREE.OrbitControls;\n\nObject.defineProperties( THREE.OrbitControls.prototype, {\n\n\tcenter: {\n\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.OrbitControls: .center has been renamed to .target' );\n\t\t\treturn this.target;\n\n\t\t}\n\n\t},\n\n\t// backward compatibility\n\n\tnoZoom: {\n\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\n\t\t\treturn ! this.enableZoom;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\n\t\t\tthis.enableZoom = ! value;\n\n\t\t}\n\n\t},\n\n\tnoRotate: {\n\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\n\t\t\treturn ! this.enableRotate;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\n\t\t\tthis.enableRotate = ! value;\n\n\t\t}\n\n\t},\n\n\tnoPan: {\n\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\n\t\t\treturn ! this.enablePan;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\n\t\t\tthis.enablePan = ! value;\n\n\t\t}\n\n\t},\n\n\tnoKeys: {\n\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\n\t\t\treturn ! this.enableKeys;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\n\t\t\tthis.enableKeys = ! value;\n\n\t\t}\n\n\t},\n\n\tstaticMoving: {\n\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\n\t\t\treturn ! this.enableDamping;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\n\t\t\tthis.enableDamping = ! value;\n\n\t\t}\n\n\t},\n\n\tdynamicDampingFactor: {\n\n\t\tget: function () {\n\n\t\t\tconsole.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\n\t\t\treturn this.dampingFactor;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tconsole.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\n\t\t\tthis.dampingFactor = value;\n\n\t\t}\n\n\t}\n\n} );\n","/**\n * @author Rich Tibbett / https://github.com/richtr\n * @author mrdoob / http://mrdoob.com/\n * @author Tony Parisi / http://www.tonyparisi.com/\n * @author Takahiro / https://github.com/takahirox\n * @author Don McCurdy / https://www.donmccurdy.com\n */\n\nTHREE.GLTFLoader = ( function () {\n\n\tfunction GLTFLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\t\tthis.dracoLoader = null;\n\n\t}\n\n\tGLTFLoader.prototype = {\n\n\t\tconstructor: GLTFLoader,\n\n\t\tcrossOrigin: 'anonymous',\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar resourcePath;\n\n\t\t\tif ( this.resourcePath !== undefined ) {\n\n\t\t\t\tresourcePath = this.resourcePath;\n\n\t\t\t} else if ( this.path !== undefined ) {\n\n\t\t\t\tresourcePath = this.path;\n\n\t\t\t} else {\n\n\t\t\t\tresourcePath = THREE.LoaderUtils.extractUrlBase( url );\n\n\t\t\t}\n\n\t\t\t// Tells the LoadingManager to track an extra item, which resolves after\n\t\t\t// the model is fully loaded. This means the count of items loaded will\n\t\t\t// be incorrect, but ensures manager.onLoad() does not fire early.\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\tvar _onError = function ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t};\n\n\t\t\tvar loader = new THREE.FileLoader( scope.manager );\n\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\t\tloader.load( url, function ( data ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tscope.parse( data, resourcePath, function ( gltf ) {\n\n\t\t\t\t\t\tonLoad( gltf );\n\n\t\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t\t}, _onError );\n\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t_onError( e );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, _onError );\n\n\t\t},\n\n\t\tsetCrossOrigin: function ( value ) {\n\n\t\t\tthis.crossOrigin = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetPath: function ( value ) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetResourcePath: function ( value ) {\n\n\t\t\tthis.resourcePath = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetDRACOLoader: function ( dracoLoader ) {\n\n\t\t\tthis.dracoLoader = dracoLoader;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tparse: function ( data, path, onLoad, onError ) {\n\n\t\t\tvar content;\n\t\t\tvar extensions = {};\n\n\t\t\tif ( typeof data === 'string' ) {\n\n\t\t\t\tcontent = data;\n\n\t\t\t} else {\n\n\t\t\t\tvar magic = THREE.LoaderUtils.decodeText( new Uint8Array( data, 0, 4 ) );\n\n\t\t\t\tif ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\textensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );\n\n\t\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\t\tif ( onError ) onError( error );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontent = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcontent = THREE.LoaderUtils.decodeText( new Uint8Array( data ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar json = JSON.parse( content );\n\n\t\t\tif ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {\n\n\t\t\t\tif ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported. Use LegacyGLTFLoader instead.' ) );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( json.extensionsUsed ) {\n\n\t\t\t\tfor ( var i = 0; i < json.extensionsUsed.length; ++ i ) {\n\n\t\t\t\t\tvar extensionName = json.extensionsUsed[ i ];\n\t\t\t\t\tvar extensionsRequired = json.extensionsRequired || [];\n\n\t\t\t\t\tswitch ( extensionName ) {\n\n\t\t\t\t\t\tcase EXTENSIONS.KHR_LIGHTS_PUNCTUAL:\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFLightsExtension( json );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_UNLIT:\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsUnlitExtension( json );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsPbrSpecularGlossinessExtension( json );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase EXTENSIONS.MSFT_TEXTURE_DDS:\n\t\t\t\t\t\t\textensions[ EXTENSIONS.MSFT_TEXTURE_DDS ] = new GLTFTextureDDSExtension();\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n\t\t\t\t\t\t\textensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] = new GLTFTextureTransformExtension( json );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tif ( extensionsRequired.indexOf( extensionName ) >= 0 ) {\n\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".' );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar parser = new GLTFParser( json, extensions, {\n\n\t\t\t\tpath: path || this.resourcePath || '',\n\t\t\t\tcrossOrigin: this.crossOrigin,\n\t\t\t\tmanager: this.manager\n\n\t\t\t} );\n\n\t\t\tparser.parse( onLoad, onError );\n\n\t\t}\n\n\t};\n\n\t/* GLTFREGISTRY */\n\n\tfunction GLTFRegistry() {\n\n\t\tvar objects = {};\n\n\t\treturn\t{\n\n\t\t\tget: function ( key ) {\n\n\t\t\t\treturn objects[ key ];\n\n\t\t\t},\n\n\t\t\tadd: function ( key, object ) {\n\n\t\t\t\tobjects[ key ] = object;\n\n\t\t\t},\n\n\t\t\tremove: function ( key ) {\n\n\t\t\t\tdelete objects[ key ];\n\n\t\t\t},\n\n\t\t\tremoveAll: function () {\n\n\t\t\t\tobjects = {};\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t/*********************************/\n\t/********** EXTENSIONS ***********/\n\t/*********************************/\n\n\tvar EXTENSIONS = {\n\t\tKHR_BINARY_GLTF: 'KHR_binary_glTF',\n\t\tKHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n\t\tKHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n\t\tKHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',\n\t\tKHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n\t\tKHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n\t\tMSFT_TEXTURE_DDS: 'MSFT_texture_dds'\n\t};\n\n\t/**\n\t * DDS Texture Extension\n\t *\n\t * Specification:\n\t * https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_texture_dds\n\t *\n\t */\n\tfunction GLTFTextureDDSExtension() {\n\n\t\tif ( ! THREE.DDSLoader ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Attempting to load .dds texture without importing THREE.DDSLoader' );\n\n\t\t}\n\n\t\tthis.name = EXTENSIONS.MSFT_TEXTURE_DDS;\n\t\tthis.ddsLoader = new THREE.DDSLoader();\n\n\t}\n\n\t/**\n\t * Lights Extension\n\t *\n\t * Specification: PENDING\n\t */\n\tfunction GLTFLightsExtension( json ) {\n\n\t\tthis.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n\n\t\tvar extension = ( json.extensions && json.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ] ) || {};\n\t\tthis.lightDefs = extension.lights || [];\n\n\t}\n\n\tGLTFLightsExtension.prototype.loadLight = function ( lightIndex ) {\n\n\t\tvar lightDef = this.lightDefs[ lightIndex ];\n\t\tvar lightNode;\n\n\t\tvar color = new THREE.Color( 0xffffff );\n\t\tif ( lightDef.color !== undefined ) color.fromArray( lightDef.color );\n\n\t\tvar range = lightDef.range !== undefined ? lightDef.range : 0;\n\n\t\tswitch ( lightDef.type ) {\n\n\t\t\tcase 'directional':\n\t\t\t\tlightNode = new THREE.DirectionalLight( color );\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\n\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\tbreak;\n\n\t\t\tcase 'point':\n\t\t\t\tlightNode = new THREE.PointLight( color );\n\t\t\t\tlightNode.distance = range;\n\t\t\t\tbreak;\n\n\t\t\tcase 'spot':\n\t\t\t\tlightNode = new THREE.SpotLight( color );\n\t\t\t\tlightNode.distance = range;\n\t\t\t\t// Handle spotlight properties.\n\t\t\t\tlightDef.spot = lightDef.spot || {};\n\t\t\t\tlightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\n\t\t\t\tlightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\n\t\t\t\tlightNode.angle = lightDef.spot.outerConeAngle;\n\t\t\t\tlightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\n\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Unexpected light type, \"' + lightDef.type + '\".' );\n\n\t\t}\n\n\t\t// Some lights (e.g. spot) default to a position other than the origin. Reset the position\n\t\t// here, because node-level parsing will only override position if explicitly specified.\n\t\tlightNode.position.set( 0, 0, 0 );\n\n\t\tlightNode.decay = 2;\n\n\t\tif ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;\n\n\t\tlightNode.name = lightDef.name || ( 'light_' + lightIndex );\n\n\t\treturn Promise.resolve( lightNode );\n\n\t};\n\n\t/**\n\t * Unlit Materials Extension (pending)\n\t *\n\t * PR: https://github.com/KhronosGroup/glTF/pull/1163\n\t */\n\tfunction GLTFMaterialsUnlitExtension() {\n\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n\n\t}\n\n\tGLTFMaterialsUnlitExtension.prototype.getMaterialType = function () {\n\n\t\treturn THREE.MeshBasicMaterial;\n\n\t};\n\n\tGLTFMaterialsUnlitExtension.prototype.extendParams = function ( materialParams, materialDef, parser ) {\n\n\t\tvar pending = [];\n\n\t\tmaterialParams.color = new THREE.Color( 1.0, 1.0, 1.0 );\n\t\tmaterialParams.opacity = 1.0;\n\n\t\tvar metallicRoughness = materialDef.pbrMetallicRoughness;\n\n\t\tif ( metallicRoughness ) {\n\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\tvar array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.fromArray( array );\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t};\n\n\t/* BINARY EXTENSION */\n\n\tvar BINARY_EXTENSION_BUFFER_NAME = 'binary_glTF';\n\tvar BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\n\tvar BINARY_EXTENSION_HEADER_LENGTH = 12;\n\tvar BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };\n\n\tfunction GLTFBinaryExtension( data ) {\n\n\t\tthis.name = EXTENSIONS.KHR_BINARY_GLTF;\n\t\tthis.content = null;\n\t\tthis.body = null;\n\n\t\tvar headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );\n\n\t\tthis.header = {\n\t\t\tmagic: THREE.LoaderUtils.decodeText( new Uint8Array( data.slice( 0, 4 ) ) ),\n\t\t\tversion: headerView.getUint32( 4, true ),\n\t\t\tlength: headerView.getUint32( 8, true )\n\t\t};\n\n\t\tif ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );\n\n\t\t} else if ( this.header.version < 2.0 ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Legacy binary file detected. Use LegacyGLTFLoader instead.' );\n\n\t\t}\n\n\t\tvar chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );\n\t\tvar chunkIndex = 0;\n\n\t\twhile ( chunkIndex < chunkView.byteLength ) {\n\n\t\t\tvar chunkLength = chunkView.getUint32( chunkIndex, true );\n\t\t\tchunkIndex += 4;\n\n\t\t\tvar chunkType = chunkView.getUint32( chunkIndex, true );\n\t\t\tchunkIndex += 4;\n\n\t\t\tif ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {\n\n\t\t\t\tvar contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );\n\t\t\t\tthis.content = THREE.LoaderUtils.decodeText( contentArray );\n\n\t\t\t} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {\n\n\t\t\t\tvar byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n\t\t\t\tthis.body = data.slice( byteOffset, byteOffset + chunkLength );\n\n\t\t\t}\n\n\t\t\t// Clients must ignore chunks with unknown types.\n\n\t\t\tchunkIndex += chunkLength;\n\n\t\t}\n\n\t\tif ( this.content === null ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: JSON content not found.' );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * DRACO Mesh Compression Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/pull/874\n\t */\n\tfunction GLTFDracoMeshCompressionExtension( json, dracoLoader ) {\n\n\t\tif ( ! dracoLoader ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );\n\n\t\t}\n\n\t\tthis.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n\t\tthis.json = json;\n\t\tthis.dracoLoader = dracoLoader;\n\n\t}\n\n\tGLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function ( primitive, parser ) {\n\n\t\tvar json = this.json;\n\t\tvar dracoLoader = this.dracoLoader;\n\t\tvar bufferViewIndex = primitive.extensions[ this.name ].bufferView;\n\t\tvar gltfAttributeMap = primitive.extensions[ this.name ].attributes;\n\t\tvar threeAttributeMap = {};\n\t\tvar attributeNormalizedMap = {};\n\t\tvar attributeTypeMap = {};\n\n\t\tfor ( var attributeName in gltfAttributeMap ) {\n\n\t\t\tvar threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\n\n\t\t\tthreeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];\n\n\t\t}\n\n\t\tfor ( attributeName in primitive.attributes ) {\n\n\t\t\tvar threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\n\n\t\t\tif ( gltfAttributeMap[ attributeName ] !== undefined ) {\n\n\t\t\t\tvar accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];\n\t\t\t\tvar componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t\tattributeTypeMap[ threeAttributeName ] = componentType;\n\t\t\t\tattributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {\n\n\t\t\treturn new Promise( function ( resolve ) {\n\n\t\t\t\tdracoLoader.decodeDracoFile( bufferView, function ( geometry ) {\n\n\t\t\t\t\tfor ( var attributeName in geometry.attributes ) {\n\n\t\t\t\t\t\tvar attribute = geometry.attributes[ attributeName ];\n\t\t\t\t\t\tvar normalized = attributeNormalizedMap[ attributeName ];\n\n\t\t\t\t\t\tif ( normalized !== undefined ) attribute.normalized = normalized;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve( geometry );\n\n\t\t\t\t}, threeAttributeMap, attributeTypeMap );\n\n\t\t\t} );\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Texture Transform Extension\n\t *\n\t * Specification:\n\t */\n\tfunction GLTFTextureTransformExtension() {\n\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n\n\t}\n\n\tGLTFTextureTransformExtension.prototype.extendTexture = function ( texture, transform ) {\n\n\t\ttexture = texture.clone();\n\n\t\tif ( transform.offset !== undefined ) {\n\n\t\t\ttexture.offset.fromArray( transform.offset );\n\n\t\t}\n\n\t\tif ( transform.rotation !== undefined ) {\n\n\t\t\ttexture.rotation = transform.rotation;\n\n\t\t}\n\n\t\tif ( transform.scale !== undefined ) {\n\n\t\t\ttexture.repeat.fromArray( transform.scale );\n\n\t\t}\n\n\t\tif ( transform.texCoord !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Custom UV sets in \"' + this.name + '\" extension not yet supported.' );\n\n\t\t}\n\n\t\ttexture.needsUpdate = true;\n\n\t\treturn texture;\n\n\t};\n\n\t/**\n\t * Specular-Glossiness Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n\t */\n\tfunction GLTFMaterialsPbrSpecularGlossinessExtension() {\n\n\t\treturn {\n\n\t\t\tname: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,\n\n\t\t\tspecularGlossinessParams: [\n\t\t\t\t'color',\n\t\t\t\t'map',\n\t\t\t\t'lightMap',\n\t\t\t\t'lightMapIntensity',\n\t\t\t\t'aoMap',\n\t\t\t\t'aoMapIntensity',\n\t\t\t\t'emissive',\n\t\t\t\t'emissiveIntensity',\n\t\t\t\t'emissiveMap',\n\t\t\t\t'bumpMap',\n\t\t\t\t'bumpScale',\n\t\t\t\t'normalMap',\n\t\t\t\t'displacementMap',\n\t\t\t\t'displacementScale',\n\t\t\t\t'displacementBias',\n\t\t\t\t'specularMap',\n\t\t\t\t'specular',\n\t\t\t\t'glossinessMap',\n\t\t\t\t'glossiness',\n\t\t\t\t'alphaMap',\n\t\t\t\t'envMap',\n\t\t\t\t'envMapIntensity',\n\t\t\t\t'refractionRatio',\n\t\t\t],\n\n\t\t\tgetMaterialType: function () {\n\n\t\t\t\treturn THREE.ShaderMaterial;\n\n\t\t\t},\n\n\t\t\textendParams: function ( materialParams, materialDef, parser ) {\n\n\t\t\t\tvar pbrSpecularGlossiness = materialDef.extensions[ this.name ];\n\n\t\t\t\tvar shader = THREE.ShaderLib[ 'standard' ];\n\n\t\t\t\tvar uniforms = THREE.UniformsUtils.clone( shader.uniforms );\n\n\t\t\t\tvar specularMapParsFragmentChunk = [\n\t\t\t\t\t'#ifdef USE_SPECULARMAP',\n\t\t\t\t\t'\tuniform sampler2D specularMap;',\n\t\t\t\t\t'#endif'\n\t\t\t\t].join( '\\n' );\n\n\t\t\t\tvar glossinessMapParsFragmentChunk = [\n\t\t\t\t\t'#ifdef USE_GLOSSINESSMAP',\n\t\t\t\t\t'\tuniform sampler2D glossinessMap;',\n\t\t\t\t\t'#endif'\n\t\t\t\t].join( '\\n' );\n\n\t\t\t\tvar specularMapFragmentChunk = [\n\t\t\t\t\t'vec3 specularFactor = specular;',\n\t\t\t\t\t'#ifdef USE_SPECULARMAP',\n\t\t\t\t\t'\tvec4 texelSpecular = texture2D( specularMap, vUv );',\n\t\t\t\t\t'\ttexelSpecular = sRGBToLinear( texelSpecular );',\n\t\t\t\t\t'\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',\n\t\t\t\t\t'\tspecularFactor *= texelSpecular.rgb;',\n\t\t\t\t\t'#endif'\n\t\t\t\t].join( '\\n' );\n\n\t\t\t\tvar glossinessMapFragmentChunk = [\n\t\t\t\t\t'float glossinessFactor = glossiness;',\n\t\t\t\t\t'#ifdef USE_GLOSSINESSMAP',\n\t\t\t\t\t'\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );',\n\t\t\t\t\t'\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',\n\t\t\t\t\t'\tglossinessFactor *= texelGlossiness.a;',\n\t\t\t\t\t'#endif'\n\t\t\t\t].join( '\\n' );\n\n\t\t\t\tvar lightPhysicalFragmentChunk = [\n\t\t\t\t\t'PhysicalMaterial material;',\n\t\t\t\t\t'material.diffuseColor = diffuseColor.rgb;',\n\t\t\t\t\t'material.specularRoughness = clamp( 1.0 - glossinessFactor, 0.04, 1.0 );',\n\t\t\t\t\t'material.specularColor = specularFactor.rgb;',\n\t\t\t\t].join( '\\n' );\n\n\t\t\t\tvar fragmentShader = shader.fragmentShader\n\t\t\t\t\t.replace( 'uniform float roughness;', 'uniform vec3 specular;' )\n\t\t\t\t\t.replace( 'uniform float metalness;', 'uniform float glossiness;' )\n\t\t\t\t\t.replace( '#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk )\n\t\t\t\t\t.replace( '#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk )\n\t\t\t\t\t.replace( '#include <roughnessmap_fragment>', specularMapFragmentChunk )\n\t\t\t\t\t.replace( '#include <metalnessmap_fragment>', glossinessMapFragmentChunk )\n\t\t\t\t\t.replace( '#include <lights_physical_fragment>', lightPhysicalFragmentChunk );\n\n\t\t\t\tdelete uniforms.roughness;\n\t\t\t\tdelete uniforms.metalness;\n\t\t\t\tdelete uniforms.roughnessMap;\n\t\t\t\tdelete uniforms.metalnessMap;\n\n\t\t\t\tuniforms.specular = { value: new THREE.Color().setHex( 0x111111 ) };\n\t\t\t\tuniforms.glossiness = { value: 0.5 };\n\t\t\t\tuniforms.specularMap = { value: null };\n\t\t\t\tuniforms.glossinessMap = { value: null };\n\n\t\t\t\tmaterialParams.vertexShader = shader.vertexShader;\n\t\t\t\tmaterialParams.fragmentShader = fragmentShader;\n\t\t\t\tmaterialParams.uniforms = uniforms;\n\t\t\t\tmaterialParams.defines = { 'STANDARD': '' };\n\n\t\t\t\tmaterialParams.color = new THREE.Color( 1.0, 1.0, 1.0 );\n\t\t\t\tmaterialParams.opacity = 1.0;\n\n\t\t\t\tvar pending = [];\n\n\t\t\t\tif ( Array.isArray( pbrSpecularGlossiness.diffuseFactor ) ) {\n\n\t\t\t\t\tvar array = pbrSpecularGlossiness.diffuseFactor;\n\n\t\t\t\t\tmaterialParams.color.fromArray( array );\n\t\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( pbrSpecularGlossiness.diffuseTexture !== undefined ) {\n\n\t\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', pbrSpecularGlossiness.diffuseTexture ) );\n\n\t\t\t\t}\n\n\t\t\t\tmaterialParams.emissive = new THREE.Color( 0.0, 0.0, 0.0 );\n\t\t\t\tmaterialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;\n\t\t\t\tmaterialParams.specular = new THREE.Color( 1.0, 1.0, 1.0 );\n\n\t\t\t\tif ( Array.isArray( pbrSpecularGlossiness.specularFactor ) ) {\n\n\t\t\t\t\tmaterialParams.specular.fromArray( pbrSpecularGlossiness.specularFactor );\n\n\t\t\t\t}\n\n\t\t\t\tif ( pbrSpecularGlossiness.specularGlossinessTexture !== undefined ) {\n\n\t\t\t\t\tvar specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;\n\t\t\t\t\tpending.push( parser.assignTexture( materialParams, 'glossinessMap', specGlossMapDef ) );\n\t\t\t\t\tpending.push( parser.assignTexture( materialParams, 'specularMap', specGlossMapDef ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn Promise.all( pending );\n\n\t\t\t},\n\n\t\t\tcreateMaterial: function ( params ) {\n\n\t\t\t\t// setup material properties based on MeshStandardMaterial for Specular-Glossiness\n\n\t\t\t\tvar material = new THREE.ShaderMaterial( {\n\t\t\t\t\tdefines: params.defines,\n\t\t\t\t\tvertexShader: params.vertexShader,\n\t\t\t\t\tfragmentShader: params.fragmentShader,\n\t\t\t\t\tuniforms: params.uniforms,\n\t\t\t\t\tfog: true,\n\t\t\t\t\tlights: true,\n\t\t\t\t\topacity: params.opacity,\n\t\t\t\t\ttransparent: params.transparent\n\t\t\t\t} );\n\n\t\t\t\tmaterial.isGLTFSpecularGlossinessMaterial = true;\n\n\t\t\t\tmaterial.color = params.color;\n\n\t\t\t\tmaterial.map = params.map === undefined ? null : params.map;\n\n\t\t\t\tmaterial.lightMap = null;\n\t\t\t\tmaterial.lightMapIntensity = 1.0;\n\n\t\t\t\tmaterial.aoMap = params.aoMap === undefined ? null : params.aoMap;\n\t\t\t\tmaterial.aoMapIntensity = 1.0;\n\n\t\t\t\tmaterial.emissive = params.emissive;\n\t\t\t\tmaterial.emissiveIntensity = 1.0;\n\t\t\t\tmaterial.emissiveMap = params.emissiveMap === undefined ? null : params.emissiveMap;\n\n\t\t\t\tmaterial.bumpMap = params.bumpMap === undefined ? null : params.bumpMap;\n\t\t\t\tmaterial.bumpScale = 1;\n\n\t\t\t\tmaterial.normalMap = params.normalMap === undefined ? null : params.normalMap;\n\n\t\t\t\tif ( params.normalScale ) material.normalScale = params.normalScale;\n\n\t\t\t\tmaterial.displacementMap = null;\n\t\t\t\tmaterial.displacementScale = 1;\n\t\t\t\tmaterial.displacementBias = 0;\n\n\t\t\t\tmaterial.specularMap = params.specularMap === undefined ? null : params.specularMap;\n\t\t\t\tmaterial.specular = params.specular;\n\n\t\t\t\tmaterial.glossinessMap = params.glossinessMap === undefined ? null : params.glossinessMap;\n\t\t\t\tmaterial.glossiness = params.glossiness;\n\n\t\t\t\tmaterial.alphaMap = null;\n\n\t\t\t\tmaterial.envMap = params.envMap === undefined ? null : params.envMap;\n\t\t\t\tmaterial.envMapIntensity = 1.0;\n\n\t\t\t\tmaterial.refractionRatio = 0.98;\n\n\t\t\t\tmaterial.extensions.derivatives = true;\n\n\t\t\t\treturn material;\n\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Clones a GLTFSpecularGlossinessMaterial instance. The ShaderMaterial.copy() method can\n\t\t\t * copy only properties it knows about or inherits, and misses many properties that would\n\t\t\t * normally be defined by MeshStandardMaterial.\n\t\t\t *\n\t\t\t * This method allows GLTFSpecularGlossinessMaterials to be cloned in the process of\n\t\t\t * loading a glTF model, but cloning later (e.g. by the user) would require these changes\n\t\t\t * AND also updating `.onBeforeRender` on the parent mesh.\n\t\t\t *\n\t\t\t * @param  {THREE.ShaderMaterial} source\n\t\t\t * @return {THREE.ShaderMaterial}\n\t\t\t */\n\t\t\tcloneMaterial: function ( source ) {\n\n\t\t\t\tvar target = source.clone();\n\n\t\t\t\ttarget.isGLTFSpecularGlossinessMaterial = true;\n\n\t\t\t\tvar params = this.specularGlossinessParams;\n\n\t\t\t\tfor ( var i = 0, il = params.length; i < il; i ++ ) {\n\n\t\t\t\t\ttarget[ params[ i ] ] = source[ params[ i ] ];\n\n\t\t\t\t}\n\n\t\t\t\treturn target;\n\n\t\t\t},\n\n\t\t\t// Here's based on refreshUniformsCommon() and refreshUniformsStandard() in WebGLRenderer.\n\t\t\trefreshUniforms: function ( renderer, scene, camera, geometry, material, group ) {\n\n\t\t\t\tif ( material.isGLTFSpecularGlossinessMaterial !== true ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tvar uniforms = material.uniforms;\n\t\t\t\tvar defines = material.defines;\n\n\t\t\t\tuniforms.opacity.value = material.opacity;\n\n\t\t\t\tuniforms.diffuse.value.copy( material.color );\n\t\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\n\n\t\t\t\tuniforms.map.value = material.map;\n\t\t\t\tuniforms.specularMap.value = material.specularMap;\n\t\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t\t\tuniforms.aoMap.value = material.aoMap;\n\t\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\n\n\t\t\t\t// uv repeat and offset setting priorities\n\t\t\t\t// 1. color map\n\t\t\t\t// 2. specular map\n\t\t\t\t// 3. normal map\n\t\t\t\t// 4. bump map\n\t\t\t\t// 5. alpha map\n\t\t\t\t// 6. emissive map\n\n\t\t\t\tvar uvScaleMap;\n\n\t\t\t\tif ( material.map ) {\n\n\t\t\t\t\tuvScaleMap = material.map;\n\n\t\t\t\t} else if ( material.specularMap ) {\n\n\t\t\t\t\tuvScaleMap = material.specularMap;\n\n\t\t\t\t} else if ( material.displacementMap ) {\n\n\t\t\t\t\tuvScaleMap = material.displacementMap;\n\n\t\t\t\t} else if ( material.normalMap ) {\n\n\t\t\t\t\tuvScaleMap = material.normalMap;\n\n\t\t\t\t} else if ( material.bumpMap ) {\n\n\t\t\t\t\tuvScaleMap = material.bumpMap;\n\n\t\t\t\t} else if ( material.glossinessMap ) {\n\n\t\t\t\t\tuvScaleMap = material.glossinessMap;\n\n\t\t\t\t} else if ( material.alphaMap ) {\n\n\t\t\t\t\tuvScaleMap = material.alphaMap;\n\n\t\t\t\t} else if ( material.emissiveMap ) {\n\n\t\t\t\t\tuvScaleMap = material.emissiveMap;\n\n\t\t\t\t}\n\n\t\t\t\tif ( uvScaleMap !== undefined ) {\n\n\t\t\t\t\t// backwards compatibility\n\t\t\t\t\tif ( uvScaleMap.isWebGLRenderTarget ) {\n\n\t\t\t\t\t\tuvScaleMap = uvScaleMap.texture;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( uvScaleMap.matrixAutoUpdate === true ) {\n\n\t\t\t\t\t\tuvScaleMap.updateMatrix();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tuniforms.uvTransform.value.copy( uvScaleMap.matrix );\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.envMap ) {\n\n\t\t\t\t\tuniforms.envMap.value = material.envMap;\n\t\t\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\n\n\t\t\t\t\t// don't flip CubeTexture envMaps, flip everything else:\n\t\t\t\t\t//  WebGLRenderTargetCube will be flipped for backwards compatibility\n\t\t\t\t\t//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\n\t\t\t\t\t// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\n\t\t\t\t\tuniforms.flipEnvMap.value = material.envMap.isCubeTexture ? - 1 : 1;\n\n\t\t\t\t\tuniforms.reflectivity.value = material.reflectivity;\n\t\t\t\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\n\t\t\t\t\tuniforms.maxMipLevel.value = renderer.properties.get( material.envMap ).__maxMipLevel;\n\n\t\t\t\t}\n\n\t\t\t\tuniforms.specular.value.copy( material.specular );\n\t\t\t\tuniforms.glossiness.value = material.glossiness;\n\n\t\t\t\tuniforms.glossinessMap.value = material.glossinessMap;\n\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t\t\tif ( uniforms.glossinessMap.value !== null && defines.USE_GLOSSINESSMAP === undefined ) {\n\n\t\t\t\t\tdefines.USE_GLOSSINESSMAP = '';\n\t\t\t\t\t// set USE_ROUGHNESSMAP to enable vUv\n\t\t\t\t\tdefines.USE_ROUGHNESSMAP = '';\n\n\t\t\t\t}\n\n\t\t\t\tif ( uniforms.glossinessMap.value === null && defines.USE_GLOSSINESSMAP !== undefined ) {\n\n\t\t\t\t\tdelete defines.USE_GLOSSINESSMAP;\n\t\t\t\t\tdelete defines.USE_ROUGHNESSMAP;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t/*********************************/\n\t/********** INTERPOLATION ********/\n\t/*********************************/\n\n\t// Spline Interpolation\n\t// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\n\tfunction GLTFCubicSplineInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tTHREE.Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tGLTFCubicSplineInterpolant.prototype = Object.create( THREE.Interpolant.prototype );\n\tGLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;\n\n\tGLTFCubicSplineInterpolant.prototype.copySampleValue_ = function ( index ) {\n\n\t\t// Copies a sample value to the result buffer. See description of glTF\n\t\t// CUBICSPLINE values layout in interpolate_() function below.\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tvalueSize = this.valueSize,\n\t\t\toffset = index * valueSize * 3 + valueSize;\n\n\t\tfor ( var i = 0; i !== valueSize; i ++ ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t};\n\n\tGLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n\n\tGLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n\n\tGLTFCubicSplineInterpolant.prototype.interpolate_ = function ( i1, t0, t, t1 ) {\n\n\t\tvar result = this.resultBuffer;\n\t\tvar values = this.sampleValues;\n\t\tvar stride = this.valueSize;\n\n\t\tvar stride2 = stride * 2;\n\t\tvar stride3 = stride * 3;\n\n\t\tvar td = t1 - t0;\n\n\t\tvar p = ( t - t0 ) / td;\n\t\tvar pp = p * p;\n\t\tvar ppp = pp * p;\n\n\t\tvar offset1 = i1 * stride3;\n\t\tvar offset0 = offset1 - stride3;\n\n\t\tvar s2 = - 2 * ppp + 3 * pp;\n\t\tvar s3 = ppp - pp;\n\t\tvar s0 = 1 - s2;\n\t\tvar s1 = s3 - pp + p;\n\n\t\t// Layout of keyframe output values for CUBICSPLINE animations:\n\t\t//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n\t\tfor ( var i = 0; i !== stride; i ++ ) {\n\n\t\t\tvar p0 = values[ offset0 + i + stride ]; // splineVertex_k\n\t\t\tvar m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)\n\t\t\tvar p1 = values[ offset1 + i + stride ]; // splineVertex_k+1\n\t\t\tvar m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)\n\n\t\t\tresult[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n\n\t\t}\n\n\t\treturn result;\n\n\t};\n\n\t/*********************************/\n\t/********** INTERNALS ************/\n\t/*********************************/\n\n\t/* CONSTANTS */\n\n\tvar WEBGL_CONSTANTS = {\n\t\tFLOAT: 5126,\n\t\t//FLOAT_MAT2: 35674,\n\t\tFLOAT_MAT3: 35675,\n\t\tFLOAT_MAT4: 35676,\n\t\tFLOAT_VEC2: 35664,\n\t\tFLOAT_VEC3: 35665,\n\t\tFLOAT_VEC4: 35666,\n\t\tLINEAR: 9729,\n\t\tREPEAT: 10497,\n\t\tSAMPLER_2D: 35678,\n\t\tPOINTS: 0,\n\t\tLINES: 1,\n\t\tLINE_LOOP: 2,\n\t\tLINE_STRIP: 3,\n\t\tTRIANGLES: 4,\n\t\tTRIANGLE_STRIP: 5,\n\t\tTRIANGLE_FAN: 6,\n\t\tUNSIGNED_BYTE: 5121,\n\t\tUNSIGNED_SHORT: 5123\n\t};\n\n\tvar WEBGL_TYPE = {\n\t\t5126: Number,\n\t\t//35674: THREE.Matrix2,\n\t\t35675: THREE.Matrix3,\n\t\t35676: THREE.Matrix4,\n\t\t35664: THREE.Vector2,\n\t\t35665: THREE.Vector3,\n\t\t35666: THREE.Vector4,\n\t\t35678: THREE.Texture\n\t};\n\n\tvar WEBGL_COMPONENT_TYPES = {\n\t\t5120: Int8Array,\n\t\t5121: Uint8Array,\n\t\t5122: Int16Array,\n\t\t5123: Uint16Array,\n\t\t5125: Uint32Array,\n\t\t5126: Float32Array\n\t};\n\n\tvar WEBGL_FILTERS = {\n\t\t9728: THREE.NearestFilter,\n\t\t9729: THREE.LinearFilter,\n\t\t9984: THREE.NearestMipMapNearestFilter,\n\t\t9985: THREE.LinearMipMapNearestFilter,\n\t\t9986: THREE.NearestMipMapLinearFilter,\n\t\t9987: THREE.LinearMipMapLinearFilter\n\t};\n\n\tvar WEBGL_WRAPPINGS = {\n\t\t33071: THREE.ClampToEdgeWrapping,\n\t\t33648: THREE.MirroredRepeatWrapping,\n\t\t10497: THREE.RepeatWrapping\n\t};\n\n\tvar WEBGL_SIDES = {\n\t\t1028: THREE.BackSide, // Culling front\n\t\t1029: THREE.FrontSide // Culling back\n\t\t//1032: THREE.NoSide   // Culling front and back, what to do?\n\t};\n\n\tvar WEBGL_DEPTH_FUNCS = {\n\t\t512: THREE.NeverDepth,\n\t\t513: THREE.LessDepth,\n\t\t514: THREE.EqualDepth,\n\t\t515: THREE.LessEqualDepth,\n\t\t516: THREE.GreaterEqualDepth,\n\t\t517: THREE.NotEqualDepth,\n\t\t518: THREE.GreaterEqualDepth,\n\t\t519: THREE.AlwaysDepth\n\t};\n\n\tvar WEBGL_BLEND_EQUATIONS = {\n\t\t32774: THREE.AddEquation,\n\t\t32778: THREE.SubtractEquation,\n\t\t32779: THREE.ReverseSubtractEquation\n\t};\n\n\tvar WEBGL_BLEND_FUNCS = {\n\t\t0: THREE.ZeroFactor,\n\t\t1: THREE.OneFactor,\n\t\t768: THREE.SrcColorFactor,\n\t\t769: THREE.OneMinusSrcColorFactor,\n\t\t770: THREE.SrcAlphaFactor,\n\t\t771: THREE.OneMinusSrcAlphaFactor,\n\t\t772: THREE.DstAlphaFactor,\n\t\t773: THREE.OneMinusDstAlphaFactor,\n\t\t774: THREE.DstColorFactor,\n\t\t775: THREE.OneMinusDstColorFactor,\n\t\t776: THREE.SrcAlphaSaturateFactor\n\t\t// The followings are not supported by Three.js yet\n\t\t//32769: CONSTANT_COLOR,\n\t\t//32770: ONE_MINUS_CONSTANT_COLOR,\n\t\t//32771: CONSTANT_ALPHA,\n\t\t//32772: ONE_MINUS_CONSTANT_COLOR\n\t};\n\n\tvar WEBGL_TYPE_SIZES = {\n\t\t'SCALAR': 1,\n\t\t'VEC2': 2,\n\t\t'VEC3': 3,\n\t\t'VEC4': 4,\n\t\t'MAT2': 4,\n\t\t'MAT3': 9,\n\t\t'MAT4': 16\n\t};\n\n\tvar ATTRIBUTES = {\n\t\tPOSITION: 'position',\n\t\tNORMAL: 'normal',\n\t\tTANGENT: 'tangent',\n\t\tTEXCOORD_0: 'uv',\n\t\tTEXCOORD_1: 'uv2',\n\t\tCOLOR_0: 'color',\n\t\tWEIGHTS_0: 'skinWeight',\n\t\tJOINTS_0: 'skinIndex',\n\t};\n\n\tvar PATH_PROPERTIES = {\n\t\tscale: 'scale',\n\t\ttranslation: 'position',\n\t\trotation: 'quaternion',\n\t\tweights: 'morphTargetInfluences'\n\t};\n\n\tvar INTERPOLATION = {\n\t\tCUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n\t\t                        // keyframe track will be initialized with a default interpolation type, then modified.\n\t\tLINEAR: THREE.InterpolateLinear,\n\t\tSTEP: THREE.InterpolateDiscrete\n\t};\n\n\tvar STATES_ENABLES = {\n\t\t2884: 'CULL_FACE',\n\t\t2929: 'DEPTH_TEST',\n\t\t3042: 'BLEND',\n\t\t3089: 'SCISSOR_TEST',\n\t\t32823: 'POLYGON_OFFSET_FILL',\n\t\t32926: 'SAMPLE_ALPHA_TO_COVERAGE'\n\t};\n\n\tvar ALPHA_MODES = {\n\t\tOPAQUE: 'OPAQUE',\n\t\tMASK: 'MASK',\n\t\tBLEND: 'BLEND'\n\t};\n\n\tvar MIME_TYPE_FORMATS = {\n\t\t'image/png': THREE.RGBAFormat,\n\t\t'image/jpeg': THREE.RGBFormat\n\t};\n\n\t/* UTILITY FUNCTIONS */\n\n\tfunction resolveURL( url, path ) {\n\n\t\t// Invalid URL\n\t\tif ( typeof url !== 'string' || url === '' ) return '';\n\n\t\t// Absolute URL http://,https://,//\n\t\tif ( /^(https?:)?\\/\\//i.test( url ) ) return url;\n\n\t\t// Data URI\n\t\tif ( /^data:.*,.*$/i.test( url ) ) return url;\n\n\t\t// Blob URL\n\t\tif ( /^blob:.*$/i.test( url ) ) return url;\n\n\t\t// Relative URL\n\t\treturn path + url;\n\n\t}\n\n\tvar defaultMaterial;\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n\t */\n\tfunction createDefaultMaterial() {\n\n\t\tdefaultMaterial = defaultMaterial || new THREE.MeshStandardMaterial( {\n\t\t\tcolor: 0xFFFFFF,\n\t\t\temissive: 0x000000,\n\t\t\tmetalness: 1,\n\t\t\troughness: 1,\n\t\t\ttransparent: false,\n\t\t\tdepthTest: true,\n\t\t\tside: THREE.FrontSide\n\t\t} );\n\n\t\treturn defaultMaterial;\n\n\t}\n\n\tfunction addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {\n\n\t\t// Add unknown glTF extensions to an object's userData.\n\n\t\tfor ( var name in objectDef.extensions ) {\n\n\t\t\tif ( knownExtensions[ name ] === undefined ) {\n\n\t\t\t\tobject.userData.gltfExtensions = object.userData.gltfExtensions || {};\n\t\t\t\tobject.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @param {THREE.Object3D|THREE.Material|THREE.BufferGeometry} object\n\t * @param {GLTF.definition} gltfDef\n\t */\n\tfunction assignExtrasToUserData( object, gltfDef ) {\n\n\t\tif ( gltfDef.extras !== undefined ) {\n\n\t\t\tif ( typeof gltfDef.extras === 'object' ) {\n\n\t\t\t\tobject.userData = gltfDef.extras;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n\t *\n\t * @param {THREE.BufferGeometry} geometry\n\t * @param {Array<GLTF.Target>} targets\n\t * @param {GLTFParser} parser\n\t * @return {Promise<THREE.BufferGeometry>}\n\t */\n\tfunction addMorphTargets( geometry, targets, parser ) {\n\n\t\tvar hasMorphPosition = false;\n\t\tvar hasMorphNormal = false;\n\n\t\tfor ( var i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\t\tvar target = targets[ i ];\n\n\t\t\tif ( target.POSITION !== undefined ) hasMorphPosition = true;\n\t\t\tif ( target.NORMAL !== undefined ) hasMorphNormal = true;\n\n\t\t\tif ( hasMorphPosition && hasMorphNormal ) break;\n\n\t\t}\n\n\t\tif ( ! hasMorphPosition && ! hasMorphNormal ) return Promise.resolve( geometry );\n\n\t\tvar pendingPositionAccessors = [];\n\t\tvar pendingNormalAccessors = [];\n\n\t\tfor ( var i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\t\tvar target = targets[ i ];\n\n\t\t\tif ( hasMorphPosition ) {\n\n\t\t\t\tvar pendingAccessor = target.POSITION !== undefined\n\t\t\t\t\t? parser.getDependency( 'accessor', target.POSITION )\n\t\t\t\t\t: geometry.attributes.position;\n\n\t\t\t\tpendingPositionAccessors.push( pendingAccessor );\n\n\t\t\t}\n\n\t\t\tif ( hasMorphNormal ) {\n\n\t\t\t\tvar pendingAccessor = target.NORMAL !== undefined\n\t\t\t\t\t? parser.getDependency( 'accessor', target.NORMAL )\n\t\t\t\t\t: geometry.attributes.normal;\n\n\t\t\t\tpendingNormalAccessors.push( pendingAccessor );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( [\n\t\t\tPromise.all( pendingPositionAccessors ),\n\t\t\tPromise.all( pendingNormalAccessors )\n\t\t] ).then( function ( accessors ) {\n\n\t\t\tvar morphPositions = accessors[ 0 ];\n\t\t\tvar morphNormals = accessors[ 1 ];\n\n\t\t\t// Clone morph target accessors before modifying them.\n\n\t\t\tfor ( var i = 0, il = morphPositions.length; i < il; i ++ ) {\n\n\t\t\t\tif ( geometry.attributes.position === morphPositions[ i ] ) continue;\n\n\t\t\t\tmorphPositions[ i ] = cloneBufferAttribute( morphPositions[ i ] );\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0, il = morphNormals.length; i < il; i ++ ) {\n\n\t\t\t\tif ( geometry.attributes.normal === morphNormals[ i ] ) continue;\n\n\t\t\t\tmorphNormals[ i ] = cloneBufferAttribute( morphNormals[ i ] );\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\t\t\tvar target = targets[ i ];\n\t\t\t\tvar attributeName = 'morphTarget' + i;\n\n\t\t\t\tif ( hasMorphPosition ) {\n\n\t\t\t\t\t// Three.js morph position is absolute value. The formula is\n\t\t\t\t\t//   basePosition\n\t\t\t\t\t//     + weight0 * ( morphPosition0 - basePosition )\n\t\t\t\t\t//     + weight1 * ( morphPosition1 - basePosition )\n\t\t\t\t\t//     ...\n\t\t\t\t\t// while the glTF one is relative\n\t\t\t\t\t//   basePosition\n\t\t\t\t\t//     + weight0 * glTFmorphPosition0\n\t\t\t\t\t//     + weight1 * glTFmorphPosition1\n\t\t\t\t\t//     ...\n\t\t\t\t\t// then we need to convert from relative to absolute here.\n\n\t\t\t\t\tif ( target.POSITION !== undefined ) {\n\n\t\t\t\t\t\tvar positionAttribute = morphPositions[ i ];\n\t\t\t\t\t\tpositionAttribute.name = attributeName;\n\n\t\t\t\t\t\tvar position = geometry.attributes.position;\n\n\t\t\t\t\t\tfor ( var j = 0, jl = positionAttribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpositionAttribute.setXYZ(\n\t\t\t\t\t\t\t\tj,\n\t\t\t\t\t\t\t\tpositionAttribute.getX( j ) + position.getX( j ),\n\t\t\t\t\t\t\t\tpositionAttribute.getY( j ) + position.getY( j ),\n\t\t\t\t\t\t\t\tpositionAttribute.getZ( j ) + position.getZ( j )\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasMorphNormal ) {\n\n\t\t\t\t\t// see target.POSITION's comment\n\n\t\t\t\t\tif ( target.NORMAL !== undefined ) {\n\n\t\t\t\t\t\tvar normalAttribute = morphNormals[ i ];\n\t\t\t\t\t\tnormalAttribute.name = attributeName;\n\n\t\t\t\t\t\tvar normal = geometry.attributes.normal;\n\n\t\t\t\t\t\tfor ( var j = 0, jl = normalAttribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tnormalAttribute.setXYZ(\n\t\t\t\t\t\t\t\tj,\n\t\t\t\t\t\t\t\tnormalAttribute.getX( j ) + normal.getX( j ),\n\t\t\t\t\t\t\t\tnormalAttribute.getY( j ) + normal.getY( j ),\n\t\t\t\t\t\t\t\tnormalAttribute.getZ( j ) + normal.getZ( j )\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;\n\t\t\tif ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;\n\n\t\t\treturn geometry;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * @param {THREE.Mesh} mesh\n\t * @param {GLTF.Mesh} meshDef\n\t */\n\tfunction updateMorphTargets( mesh, meshDef ) {\n\n\t\tmesh.updateMorphTargets();\n\n\t\tif ( meshDef.weights !== undefined ) {\n\n\t\t\tfor ( var i = 0, il = meshDef.weights.length; i < il; i ++ ) {\n\n\t\t\t\tmesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// .extras has user-defined data, so check that .extras.targetNames is an array.\n\t\tif ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {\n\n\t\t\tvar targetNames = meshDef.extras.targetNames;\n\n\t\t\tif ( mesh.morphTargetInfluences.length === targetNames.length ) {\n\n\t\t\t\tmesh.morphTargetDictionary = {};\n\n\t\t\t\tfor ( var i = 0, il = targetNames.length; i < il; i ++ ) {\n\n\t\t\t\t\tmesh.morphTargetDictionary[ targetNames[ i ] ] = i;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\tfunction isObjectEqual( a, b ) {\n\n\t\tif ( Object.keys( a ).length !== Object.keys( b ).length ) return false;\n\n\t\tfor ( var key in a ) {\n\n\t\t\tif ( a[ key ] !== b[ key ] ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfunction createPrimitiveKey( primitiveDef ) {\n\n\t\tvar dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];\n\t\tvar geometryKey;\n\n\t\tif ( dracoExtension ) {\n\n\t\t\tgeometryKey = 'draco:' + dracoExtension.bufferView\n\t\t\t\t+ ':' + dracoExtension.indices\n\t\t\t\t+ ':' + createAttributesKey( dracoExtension.attributes );\n\n\t\t} else {\n\n\t\t\tgeometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;\n\n\t\t}\n\n\t\treturn geometryKey;\n\n\t}\n\n\tfunction createAttributesKey( attributes ) {\n\n\t\tvar attributesKey = '';\n\n\t\tvar keys = Object.keys( attributes ).sort();\n\n\t\tfor ( var i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\t\tattributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';\n\n\t\t}\n\n\t\treturn attributesKey;\n\n\t}\n\n\tfunction cloneBufferAttribute( attribute ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tvar count = attribute.count;\n\t\t\tvar itemSize = attribute.itemSize;\n\t\t\tvar array = attribute.array.slice( 0, count * itemSize );\n\n\t\t\tfor ( var i = 0, j = 0; i < count; ++ i ) {\n\n\t\t\t\tarray[ j ++ ] = attribute.getX( i );\n\t\t\t\tif ( itemSize >= 2 ) array[ j ++ ] = attribute.getY( i );\n\t\t\t\tif ( itemSize >= 3 ) array[ j ++ ] = attribute.getZ( i );\n\t\t\t\tif ( itemSize >= 4 ) array[ j ++ ] = attribute.getW( i );\n\n\t\t\t}\n\n\t\t\treturn new THREE.BufferAttribute( array, itemSize, attribute.normalized );\n\n\t\t}\n\n\t\treturn attribute.clone();\n\n\t}\n\n\t/* GLTF PARSER */\n\n\tfunction GLTFParser( json, extensions, options ) {\n\n\t\tthis.json = json || {};\n\t\tthis.extensions = extensions || {};\n\t\tthis.options = options || {};\n\n\t\t// loader object cache\n\t\tthis.cache = new GLTFRegistry();\n\n\t\t// BufferGeometry caching\n\t\tthis.primitiveCache = {};\n\n\t\tthis.textureLoader = new THREE.TextureLoader( this.options.manager );\n\t\tthis.textureLoader.setCrossOrigin( this.options.crossOrigin );\n\n\t\tthis.fileLoader = new THREE.FileLoader( this.options.manager );\n\t\tthis.fileLoader.setResponseType( 'arraybuffer' );\n\n\t}\n\n\tGLTFParser.prototype.parse = function ( onLoad, onError ) {\n\n\t\tvar parser = this;\n\t\tvar json = this.json;\n\t\tvar extensions = this.extensions;\n\n\t\t// Clear the loader cache\n\t\tthis.cache.removeAll();\n\n\t\t// Mark the special nodes/meshes in json for efficient parse\n\t\tthis.markDefs();\n\n\t\tPromise.all( [\n\n\t\t\tthis.getDependencies( 'scene' ),\n\t\t\tthis.getDependencies( 'animation' ),\n\t\t\tthis.getDependencies( 'camera' ),\n\n\t\t] ).then( function ( dependencies ) {\n\n\t\t\tvar result = {\n\t\t\t\tscene: dependencies[ 0 ][ json.scene || 0 ],\n\t\t\t\tscenes: dependencies[ 0 ],\n\t\t\t\tanimations: dependencies[ 1 ],\n\t\t\t\tcameras: dependencies[ 2 ],\n\t\t\t\tasset: json.asset,\n\t\t\t\tparser: parser,\n\t\t\t\tuserData: {}\n\t\t\t};\n\n\t\t\taddUnknownExtensionsToUserData( extensions, result, json );\n\n\t\t\tonLoad( result );\n\n\t\t} ).catch( onError );\n\n\t};\n\n\t/**\n\t * Marks the special nodes/meshes in json for efficient parse.\n\t */\n\tGLTFParser.prototype.markDefs = function () {\n\n\t\tvar nodeDefs = this.json.nodes || [];\n\t\tvar skinDefs = this.json.skins || [];\n\t\tvar meshDefs = this.json.meshes || [];\n\n\t\tvar meshReferences = {};\n\t\tvar meshUses = {};\n\n\t\t// Nothing in the node definition indicates whether it is a Bone or an\n\t\t// Object3D. Use the skins' joint references to mark bones.\n\t\tfor ( var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {\n\n\t\t\tvar joints = skinDefs[ skinIndex ].joints;\n\n\t\t\tfor ( var i = 0, il = joints.length; i < il; i ++ ) {\n\n\t\t\t\tnodeDefs[ joints[ i ] ].isBone = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Meshes can (and should) be reused by multiple nodes in a glTF asset. To\n\t\t// avoid having more than one THREE.Mesh with the same name, count\n\t\t// references and rename instances below.\n\t\t//\n\t\t// Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n\t\tfor ( var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\n\n\t\t\tvar nodeDef = nodeDefs[ nodeIndex ];\n\n\t\t\tif ( nodeDef.mesh !== undefined ) {\n\n\t\t\t\tif ( meshReferences[ nodeDef.mesh ] === undefined ) {\n\n\t\t\t\t\tmeshReferences[ nodeDef.mesh ] = meshUses[ nodeDef.mesh ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\tmeshReferences[ nodeDef.mesh ] ++;\n\n\t\t\t\t// Nothing in the mesh definition indicates whether it is\n\t\t\t\t// a SkinnedMesh or Mesh. Use the node's mesh reference\n\t\t\t\t// to mark SkinnedMesh if node has skin.\n\t\t\t\tif ( nodeDef.skin !== undefined ) {\n\n\t\t\t\t\tmeshDefs[ nodeDef.mesh ].isSkinnedMesh = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.json.meshReferences = meshReferences;\n\t\tthis.json.meshUses = meshUses;\n\n\t};\n\n\t/**\n\t * Requests the specified dependency asynchronously, with caching.\n\t * @param {string} type\n\t * @param {number} index\n\t * @return {Promise<THREE.Object3D|THREE.Material|THREE.Texture|THREE.AnimationClip|ArrayBuffer|Object>}\n\t */\n\tGLTFParser.prototype.getDependency = function ( type, index ) {\n\n\t\tvar cacheKey = type + ':' + index;\n\t\tvar dependency = this.cache.get( cacheKey );\n\n\t\tif ( ! dependency ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'scene':\n\t\t\t\t\tdependency = this.loadScene( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'node':\n\t\t\t\t\tdependency = this.loadNode( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'mesh':\n\t\t\t\t\tdependency = this.loadMesh( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'accessor':\n\t\t\t\t\tdependency = this.loadAccessor( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bufferView':\n\t\t\t\t\tdependency = this.loadBufferView( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'buffer':\n\t\t\t\t\tdependency = this.loadBuffer( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'material':\n\t\t\t\t\tdependency = this.loadMaterial( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'texture':\n\t\t\t\t\tdependency = this.loadTexture( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'skin':\n\t\t\t\t\tdependency = this.loadSkin( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'animation':\n\t\t\t\t\tdependency = this.loadAnimation( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'camera':\n\t\t\t\t\tdependency = this.loadCamera( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'light':\n\t\t\t\t\tdependency = this.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ].loadLight( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'Unknown type: ' + type );\n\n\t\t\t}\n\n\t\t\tthis.cache.add( cacheKey, dependency );\n\n\t\t}\n\n\t\treturn dependency;\n\n\t};\n\n\t/**\n\t * Requests all dependencies of the specified type asynchronously, with caching.\n\t * @param {string} type\n\t * @return {Promise<Array<Object>>}\n\t */\n\tGLTFParser.prototype.getDependencies = function ( type ) {\n\n\t\tvar dependencies = this.cache.get( type );\n\n\t\tif ( ! dependencies ) {\n\n\t\t\tvar parser = this;\n\t\t\tvar defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];\n\n\t\t\tdependencies = Promise.all( defs.map( function ( def, index ) {\n\n\t\t\t\treturn parser.getDependency( type, index );\n\n\t\t\t} ) );\n\n\t\t\tthis.cache.add( type, dependencies );\n\n\t\t}\n\n\t\treturn dependencies;\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t * @param {number} bufferIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tGLTFParser.prototype.loadBuffer = function ( bufferIndex ) {\n\n\t\tvar bufferDef = this.json.buffers[ bufferIndex ];\n\t\tvar loader = this.fileLoader;\n\n\t\tif ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );\n\n\t\t}\n\n\t\t// If present, GLB container is required to be the first buffer.\n\t\tif ( bufferDef.uri === undefined && bufferIndex === 0 ) {\n\n\t\t\treturn Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );\n\n\t\t}\n\n\t\tvar options = this.options;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tloader.load( resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {\n\n\t\t\t\treject( new Error( 'THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".' ) );\n\n\t\t\t} );\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t * @param {number} bufferViewIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tGLTFParser.prototype.loadBufferView = function ( bufferViewIndex ) {\n\n\t\tvar bufferViewDef = this.json.bufferViews[ bufferViewIndex ];\n\n\t\treturn this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {\n\n\t\t\tvar byteLength = bufferViewDef.byteLength || 0;\n\t\t\tvar byteOffset = bufferViewDef.byteOffset || 0;\n\t\t\treturn buffer.slice( byteOffset, byteOffset + byteLength );\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n\t * @param {number} accessorIndex\n\t * @return {Promise<THREE.BufferAttribute|THREE.InterleavedBufferAttribute>}\n\t */\n\tGLTFParser.prototype.loadAccessor = function ( accessorIndex ) {\n\n\t\tvar parser = this;\n\t\tvar json = this.json;\n\n\t\tvar accessorDef = this.json.accessors[ accessorIndex ];\n\n\t\tif ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {\n\n\t\t\t// Ignore empty accessors, which may be used to declare runtime\n\t\t\t// information about attributes coming from another source (e.g. Draco\n\t\t\t// compression extension).\n\t\t\treturn Promise.resolve( null );\n\n\t\t}\n\n\t\tvar pendingBufferViews = [];\n\n\t\tif ( accessorDef.bufferView !== undefined ) {\n\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );\n\n\t\t} else {\n\n\t\t\tpendingBufferViews.push( null );\n\n\t\t}\n\n\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );\n\n\t\t}\n\n\t\treturn Promise.all( pendingBufferViews ).then( function ( bufferViews ) {\n\n\t\t\tvar bufferView = bufferViews[ 0 ];\n\n\t\t\tvar itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];\n\t\t\tvar TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\t\t\tvar elementBytes = TypedArray.BYTES_PER_ELEMENT;\n\t\t\tvar itemBytes = elementBytes * itemSize;\n\t\t\tvar byteOffset = accessorDef.byteOffset || 0;\n\t\t\tvar byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;\n\t\t\tvar normalized = accessorDef.normalized === true;\n\t\t\tvar array, bufferAttribute;\n\n\t\t\t// The buffer is not interleaved if the stride is the item size in bytes.\n\t\t\tif ( byteStride && byteStride !== itemBytes ) {\n\n\t\t\t\tvar ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType;\n\t\t\t\tvar ib = parser.cache.get( ibCacheKey );\n\n\t\t\t\tif ( ! ib ) {\n\n\t\t\t\t\t// Use the full buffer if it's interleaved.\n\t\t\t\t\tarray = new TypedArray( bufferView );\n\n\t\t\t\t\t// Integer parameters to IB/IBA are in array elements, not bytes.\n\t\t\t\t\tib = new THREE.InterleavedBuffer( array, byteStride / elementBytes );\n\n\t\t\t\t\tparser.cache.add( ibCacheKey, ib );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new THREE.InterleavedBufferAttribute( ib, itemSize, byteOffset / elementBytes, normalized );\n\n\t\t\t} else {\n\n\t\t\t\tif ( bufferView === null ) {\n\n\t\t\t\t\tarray = new TypedArray( accessorDef.count * itemSize );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tarray = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new THREE.BufferAttribute( array, itemSize, normalized );\n\n\t\t\t}\n\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n\t\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\t\tvar itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n\t\t\t\tvar TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];\n\n\t\t\t\tvar byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n\t\t\t\tvar byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n\n\t\t\t\tvar sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );\n\t\t\t\tvar sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );\n\n\t\t\t\tif ( bufferView !== null ) {\n\n\t\t\t\t\t// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n\t\t\t\t\tbufferAttribute.setArray( bufferAttribute.array.slice() );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0, il = sparseIndices.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar index = sparseIndices[ i ];\n\n\t\t\t\t\tbufferAttribute.setX( index, sparseValues[ i * itemSize ] );\n\t\t\t\t\tif ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );\n\t\t\t\t\tif ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );\n\t\t\t\t\tif ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );\n\t\t\t\t\tif ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn bufferAttribute;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n\t * @param {number} textureIndex\n\t * @return {Promise<THREE.Texture>}\n\t */\n\tGLTFParser.prototype.loadTexture = function ( textureIndex ) {\n\n\t\tvar parser = this;\n\t\tvar json = this.json;\n\t\tvar options = this.options;\n\t\tvar textureLoader = this.textureLoader;\n\n\t\tvar URL = window.URL || window.webkitURL;\n\n\t\tvar textureDef = json.textures[ textureIndex ];\n\n\t\tvar textureExtensions = textureDef.extensions || {};\n\n\t\tvar source;\n\n\t\tif ( textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ] ) {\n\n\t\t\tsource = json.images[ textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ].source ];\n\n\t\t} else {\n\n\t\t\tsource = json.images[ textureDef.source ];\n\n\t\t}\n\n\t\tvar sourceURI = source.uri;\n\t\tvar isObjectURL = false;\n\n\t\tif ( source.bufferView !== undefined ) {\n\n\t\t\t// Load binary image data from bufferView, if provided.\n\n\t\t\tsourceURI = parser.getDependency( 'bufferView', source.bufferView ).then( function ( bufferView ) {\n\n\t\t\t\tisObjectURL = true;\n\t\t\t\tvar blob = new Blob( [ bufferView ], { type: source.mimeType } );\n\t\t\t\tsourceURI = URL.createObjectURL( blob );\n\t\t\t\treturn sourceURI;\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn Promise.resolve( sourceURI ).then( function ( sourceURI ) {\n\n\t\t\t// Load Texture resource.\n\n\t\t\tvar loader = THREE.Loader.Handlers.get( sourceURI );\n\n\t\t\tif ( ! loader ) {\n\n\t\t\t\tloader = textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ]\n\t\t\t\t\t? parser.extensions[ EXTENSIONS.MSFT_TEXTURE_DDS ].ddsLoader\n\t\t\t\t\t: textureLoader;\n\n\t\t\t}\n\n\t\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\t\tloader.load( resolveURL( sourceURI, options.path ), resolve, undefined, reject );\n\n\t\t\t} );\n\n\t\t} ).then( function ( texture ) {\n\n\t\t\t// Clean up resources and configure Texture.\n\n\t\t\tif ( isObjectURL === true ) {\n\n\t\t\t\tURL.revokeObjectURL( sourceURI );\n\n\t\t\t}\n\n\t\t\ttexture.flipY = false;\n\n\t\t\tif ( textureDef.name !== undefined ) texture.name = textureDef.name;\n\n\t\t\t// Ignore unknown mime types, like DDS files.\n\t\t\tif ( source.mimeType in MIME_TYPE_FORMATS ) {\n\n\t\t\t\ttexture.format = MIME_TYPE_FORMATS[ source.mimeType ];\n\n\t\t\t}\n\n\t\t\tvar samplers = json.samplers || {};\n\t\t\tvar sampler = samplers[ textureDef.sampler ] || {};\n\n\t\t\ttexture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || THREE.LinearFilter;\n\t\t\ttexture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || THREE.LinearMipMapLinearFilter;\n\t\t\ttexture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || THREE.RepeatWrapping;\n\t\t\ttexture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || THREE.RepeatWrapping;\n\n\t\t\treturn texture;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Asynchronously assigns a texture to the given material parameters.\n\t * @param {Object} materialParams\n\t * @param {string} mapName\n\t * @param {Object} mapDef\n\t * @return {Promise}\n\t */\n\tGLTFParser.prototype.assignTexture = function ( materialParams, mapName, mapDef ) {\n\n\t\tvar parser = this;\n\n\t\treturn this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {\n\n\t\t\tif ( ! texture.isCompressedTexture ) {\n\n\t\t\t\tswitch ( mapName ) {\n\n\t\t\t\t\tcase 'aoMap':\n\t\t\t\t\tcase 'emissiveMap':\n\t\t\t\t\tcase 'metalnessMap':\n\t\t\t\t\tcase 'normalMap':\n\t\t\t\t\tcase 'roughnessMap':\n\t\t\t\t\t\ttexture.format = THREE.RGBFormat;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {\n\n\t\t\t\tvar transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;\n\n\t\t\t\tif ( transform ) {\n\n\t\t\t\t\ttexture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tmaterialParams[ mapName ] = texture;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Assigns final material to a Mesh, Line, or Points instance. The instance\n\t * already has a material (generated from the glTF material options alone)\n\t * but reuse of the same glTF material may require multiple threejs materials\n\t * to accomodate different primitive types, defines, etc. New materials will\n\t * be created if necessary, and reused from a cache.\n\t * @param  {THREE.Object3D} mesh Mesh, Line, or Points instance.\n\t */\n\tGLTFParser.prototype.assignFinalMaterial = function ( mesh ) {\n\n\t\tvar geometry = mesh.geometry;\n\t\tvar material = mesh.material;\n\t\tvar extensions = this.extensions;\n\n\t\tvar useVertexTangents = geometry.attributes.tangent !== undefined;\n\t\tvar useVertexColors = geometry.attributes.color !== undefined;\n\t\tvar useFlatShading = geometry.attributes.normal === undefined;\n\t\tvar useSkinning = mesh.isSkinnedMesh === true;\n\t\tvar useMorphTargets = Object.keys( geometry.morphAttributes ).length > 0;\n\t\tvar useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;\n\n\t\tif ( mesh.isPoints ) {\n\n\t\t\tvar cacheKey = 'PointsMaterial:' + material.uuid;\n\n\t\t\tvar pointsMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! pointsMaterial ) {\n\n\t\t\t\tpointsMaterial = new THREE.PointsMaterial();\n\t\t\t\tTHREE.Material.prototype.copy.call( pointsMaterial, material );\n\t\t\t\tpointsMaterial.color.copy( material.color );\n\t\t\t\tpointsMaterial.map = material.map;\n\t\t\t\tpointsMaterial.lights = false; // PointsMaterial doesn't support lights yet\n\n\t\t\t\tthis.cache.add( cacheKey, pointsMaterial );\n\n\t\t\t}\n\n\t\t\tmaterial = pointsMaterial;\n\n\t\t} else if ( mesh.isLine ) {\n\n\t\t\tvar cacheKey = 'LineBasicMaterial:' + material.uuid;\n\n\t\t\tvar lineMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! lineMaterial ) {\n\n\t\t\t\tlineMaterial = new THREE.LineBasicMaterial();\n\t\t\t\tTHREE.Material.prototype.copy.call( lineMaterial, material );\n\t\t\t\tlineMaterial.color.copy( material.color );\n\t\t\t\tlineMaterial.lights = false; // LineBasicMaterial doesn't support lights yet\n\n\t\t\t\tthis.cache.add( cacheKey, lineMaterial );\n\n\t\t\t}\n\n\t\t\tmaterial = lineMaterial;\n\n\t\t}\n\n\t\t// Clone the material if it will be modified\n\t\tif ( useVertexTangents || useVertexColors || useFlatShading || useSkinning || useMorphTargets ) {\n\n\t\t\tvar cacheKey = 'ClonedMaterial:' + material.uuid + ':';\n\n\t\t\tif ( material.isGLTFSpecularGlossinessMaterial ) cacheKey += 'specular-glossiness:';\n\t\t\tif ( useSkinning ) cacheKey += 'skinning:';\n\t\t\tif ( useVertexTangents ) cacheKey += 'vertex-tangents:';\n\t\t\tif ( useVertexColors ) cacheKey += 'vertex-colors:';\n\t\t\tif ( useFlatShading ) cacheKey += 'flat-shading:';\n\t\t\tif ( useMorphTargets ) cacheKey += 'morph-targets:';\n\t\t\tif ( useMorphNormals ) cacheKey += 'morph-normals:';\n\n\t\t\tvar cachedMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! cachedMaterial ) {\n\n\t\t\t\tcachedMaterial = material.isGLTFSpecularGlossinessMaterial\n\t\t\t\t\t? extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].cloneMaterial( material )\n\t\t\t\t\t: material.clone();\n\n\t\t\t\tif ( useSkinning ) cachedMaterial.skinning = true;\n\t\t\t\tif ( useVertexTangents ) cachedMaterial.vertexTangents = true;\n\t\t\t\tif ( useVertexColors ) cachedMaterial.vertexColors = THREE.VertexColors;\n\t\t\t\tif ( useFlatShading ) cachedMaterial.flatShading = true;\n\t\t\t\tif ( useMorphTargets ) cachedMaterial.morphTargets = true;\n\t\t\t\tif ( useMorphNormals ) cachedMaterial.morphNormals = true;\n\n\t\t\t\tthis.cache.add( cacheKey, cachedMaterial );\n\n\t\t\t}\n\n\t\t\tmaterial = cachedMaterial;\n\n\t\t}\n\n\t\t// workarounds for mesh and geometry\n\n\t\tif ( material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined ) {\n\n\t\t\tconsole.log( 'THREE.GLTFLoader: Duplicating UVs to support aoMap.' );\n\t\t\tgeometry.addAttribute( 'uv2', new THREE.BufferAttribute( geometry.attributes.uv.array, 2 ) );\n\n\t\t}\n\n\t\tif ( material.isGLTFSpecularGlossinessMaterial ) {\n\n\t\t\t// for GLTFSpecularGlossinessMaterial(ShaderMaterial) uniforms runtime update\n\t\t\tmesh.onBeforeRender = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].refreshUniforms;\n\n\t\t}\n\n\t\tmesh.material = material;\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n\t * @param {number} materialIndex\n\t * @return {Promise<THREE.Material>}\n\t */\n\tGLTFParser.prototype.loadMaterial = function ( materialIndex ) {\n\n\t\tvar parser = this;\n\t\tvar json = this.json;\n\t\tvar extensions = this.extensions;\n\t\tvar materialDef = json.materials[ materialIndex ];\n\n\t\tvar materialType;\n\t\tvar materialParams = {};\n\t\tvar materialExtensions = materialDef.extensions || {};\n\n\t\tvar pending = [];\n\n\t\tif ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] ) {\n\n\t\t\tvar sgExtension = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ];\n\t\t\tmaterialType = sgExtension.getMaterialType();\n\t\t\tpending.push( sgExtension.extendParams( materialParams, materialDef, parser ) );\n\n\t\t} else if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {\n\n\t\t\tvar kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];\n\t\t\tmaterialType = kmuExtension.getMaterialType();\n\t\t\tpending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );\n\n\t\t} else {\n\n\t\t\t// Specification:\n\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n\n\t\t\tmaterialType = THREE.MeshStandardMaterial;\n\n\t\t\tvar metallicRoughness = materialDef.pbrMetallicRoughness || {};\n\n\t\t\tmaterialParams.color = new THREE.Color( 1.0, 1.0, 1.0 );\n\t\t\tmaterialParams.opacity = 1.0;\n\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\tvar array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.fromArray( array );\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );\n\n\t\t\t}\n\n\t\t\tmaterialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n\t\t\tmaterialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n\n\t\t\tif ( metallicRoughness.metallicRoughnessTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.doubleSided === true ) {\n\n\t\t\tmaterialParams.side = THREE.DoubleSide;\n\n\t\t}\n\n\t\tvar alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n\n\t\tif ( alphaMode === ALPHA_MODES.BLEND ) {\n\n\t\t\tmaterialParams.transparent = true;\n\n\t\t} else {\n\n\t\t\tmaterialParams.transparent = false;\n\n\t\t\tif ( alphaMode === ALPHA_MODES.MASK ) {\n\n\t\t\t\tmaterialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.normalTexture !== undefined && materialType !== THREE.MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );\n\n\t\t\tmaterialParams.normalScale = new THREE.Vector2( 1, 1 );\n\n\t\t\tif ( materialDef.normalTexture.scale !== undefined ) {\n\n\t\t\t\tmaterialParams.normalScale.set( materialDef.normalTexture.scale, materialDef.normalTexture.scale );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.occlusionTexture !== undefined && materialType !== THREE.MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );\n\n\t\t\tif ( materialDef.occlusionTexture.strength !== undefined ) {\n\n\t\t\t\tmaterialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.emissiveFactor !== undefined && materialType !== THREE.MeshBasicMaterial ) {\n\n\t\t\tmaterialParams.emissive = new THREE.Color().fromArray( materialDef.emissiveFactor );\n\n\t\t}\n\n\t\tif ( materialDef.emissiveTexture !== undefined && materialType !== THREE.MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function () {\n\n\t\t\tvar material;\n\n\t\t\tif ( materialType === THREE.ShaderMaterial ) {\n\n\t\t\t\tmaterial = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].createMaterial( materialParams );\n\n\t\t\t} else {\n\n\t\t\t\tmaterial = new materialType( materialParams );\n\n\t\t\t}\n\n\t\t\tif ( materialDef.name !== undefined ) material.name = materialDef.name;\n\n\t\t\t// baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.\n\t\t\tif ( material.map ) material.map.encoding = THREE.sRGBEncoding;\n\t\t\tif ( material.emissiveMap ) material.emissiveMap.encoding = THREE.sRGBEncoding;\n\t\t\tif ( material.specularMap ) material.specularMap.encoding = THREE.sRGBEncoding;\n\n\t\t\tassignExtrasToUserData( material, materialDef );\n\n\t\t\tif ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );\n\n\t\t\treturn material;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * @param {THREE.BufferGeometry} geometry\n\t * @param {GLTF.Primitive} primitiveDef\n\t * @param {GLTFParser} parser\n\t * @return {Promise<THREE.BufferGeometry>}\n\t */\n\tfunction addPrimitiveAttributes( geometry, primitiveDef, parser ) {\n\n\t\tvar attributes = primitiveDef.attributes;\n\n\t\tvar pending = [];\n\n\t\tfunction assignAttributeAccessor( accessorIndex, attributeName ) {\n\n\t\t\treturn parser.getDependency( 'accessor', accessorIndex )\n\t\t\t\t.then( function ( accessor ) {\n\n\t\t\t\t\tgeometry.addAttribute( attributeName, accessor );\n\n\t\t\t\t} );\n\n\t\t}\n\n\t\tfor ( var gltfAttributeName in attributes ) {\n\n\t\t\tvar threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();\n\n\t\t\t// Skip attributes already provided by e.g. Draco extension.\n\t\t\tif ( threeAttributeName in geometry.attributes ) continue;\n\n\t\t\tpending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );\n\n\t\t}\n\n\t\tif ( primitiveDef.indices !== undefined && ! geometry.index ) {\n\n\t\t\tvar accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {\n\n\t\t\t\tgeometry.setIndex( accessor );\n\n\t\t\t} );\n\n\t\t\tpending.push( accessor );\n\n\t\t}\n\n\t\tassignExtrasToUserData( geometry, primitiveDef );\n\n\t\treturn Promise.all( pending ).then( function () {\n\n\t\t\treturn primitiveDef.targets !== undefined\n\t\t\t\t? addMorphTargets( geometry, primitiveDef.targets, parser )\n\t\t\t\t: geometry;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n\t *\n\t * Creates BufferGeometries from primitives.\n\t *\n\t * @param {Array<GLTF.Primitive>} primitives\n\t * @return {Promise<Array<THREE.BufferGeometry>>}\n\t */\n\tGLTFParser.prototype.loadGeometries = function ( primitives ) {\n\n\t\tvar parser = this;\n\t\tvar extensions = this.extensions;\n\t\tvar cache = this.primitiveCache;\n\n\t\tfunction createDracoPrimitive( primitive ) {\n\n\t\t\treturn extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]\n\t\t\t\t.decodePrimitive( primitive, parser )\n\t\t\t\t.then( function ( geometry ) {\n\n\t\t\t\t\treturn addPrimitiveAttributes( geometry, primitive, parser );\n\n\t\t\t\t} );\n\n\t\t}\n\n\t\tvar pending = [];\n\n\t\tfor ( var i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\tvar primitive = primitives[ i ];\n\t\t\tvar cacheKey = createPrimitiveKey( primitive );\n\n\t\t\t// See if we've already created this geometry\n\t\t\tvar cached = cache[ cacheKey ];\n\n\t\t\tif ( cached ) {\n\n\t\t\t\t// Use the cached geometry if it exists\n\t\t\t\tpending.push( cached.promise );\n\n\t\t\t} else {\n\n\t\t\t\tvar geometryPromise;\n\n\t\t\t\tif ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {\n\n\t\t\t\t\t// Use DRACO geometry if available\n\t\t\t\t\tgeometryPromise = createDracoPrimitive( primitive );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Otherwise create a new geometry\n\t\t\t\t\tgeometryPromise = addPrimitiveAttributes( new THREE.BufferGeometry(), primitive, parser );\n\n\t\t\t\t}\n\n\t\t\t\t// Cache this geometry\n\t\t\t\tcache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };\n\n\t\t\t\tpending.push( geometryPromise );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n\t * @param {number} meshIndex\n\t * @return {Promise<THREE.Group|THREE.Mesh|THREE.SkinnedMesh>}\n\t */\n\tGLTFParser.prototype.loadMesh = function ( meshIndex ) {\n\n\t\tvar parser = this;\n\t\tvar json = this.json;\n\t\tvar extensions = this.extensions;\n\n\t\tvar meshDef = json.meshes[ meshIndex ];\n\t\tvar primitives = meshDef.primitives;\n\n\t\tvar pending = [];\n\n\t\tfor ( var i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\tvar material = primitives[ i ].material === undefined\n\t\t\t\t? createDefaultMaterial()\n\t\t\t\t: this.getDependency( 'material', primitives[ i ].material );\n\n\t\t\tpending.push( material );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function ( originalMaterials ) {\n\n\t\t\treturn parser.loadGeometries( primitives ).then( function ( geometries ) {\n\n\t\t\t\tvar meshes = [];\n\n\t\t\t\tfor ( var i = 0, il = geometries.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar geometry = geometries[ i ];\n\t\t\t\t\tvar primitive = primitives[ i ];\n\n\t\t\t\t\t// 1. create Mesh\n\n\t\t\t\t\tvar mesh;\n\n\t\t\t\t\tvar material = originalMaterials[ i ];\n\n\t\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||\n\t\t\t\t\t\tprimitive.mode === undefined ) {\n\n\t\t\t\t\t\t// .isSkinnedMesh isn't in glTF spec. See .markDefs()\n\t\t\t\t\t\tmesh = meshDef.isSkinnedMesh === true\n\t\t\t\t\t\t\t? new THREE.SkinnedMesh( geometry, material )\n\t\t\t\t\t\t\t: new THREE.Mesh( geometry, material );\n\n\t\t\t\t\t\tif ( mesh.isSkinnedMesh === true ) mesh.normalizeSkinWeights(); // #15319\n\n\t\t\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {\n\n\t\t\t\t\t\t\tmesh.drawMode = THREE.TriangleStripDrawMode;\n\n\t\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {\n\n\t\t\t\t\t\t\tmesh.drawMode = THREE.TriangleFanDrawMode;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {\n\n\t\t\t\t\t\tmesh = new THREE.LineSegments( geometry, material );\n\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {\n\n\t\t\t\t\t\tmesh = new THREE.Line( geometry, material );\n\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {\n\n\t\t\t\t\t\tmesh = new THREE.LineLoop( geometry, material );\n\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {\n\n\t\t\t\t\t\tmesh = new THREE.Points( geometry, material );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {\n\n\t\t\t\t\t\tupdateMorphTargets( mesh, meshDef );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmesh.name = meshDef.name || ( 'mesh_' + meshIndex );\n\n\t\t\t\t\tif ( geometries.length > 1 ) mesh.name += '_' + i;\n\n\t\t\t\t\tassignExtrasToUserData( mesh, meshDef );\n\n\t\t\t\t\tparser.assignFinalMaterial( mesh );\n\n\t\t\t\t\tmeshes.push( mesh );\n\n\t\t\t\t}\n\n\t\t\t\tif ( meshes.length === 1 ) {\n\n\t\t\t\t\treturn meshes[ 0 ];\n\n\t\t\t\t}\n\n\t\t\t\tvar group = new THREE.Group();\n\n\t\t\t\tfor ( var i = 0, il = meshes.length; i < il; i ++ ) {\n\n\t\t\t\t\tgroup.add( meshes[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn group;\n\n\t\t\t} );\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n\t * @param {number} cameraIndex\n\t * @return {Promise<THREE.Camera>}\n\t */\n\tGLTFParser.prototype.loadCamera = function ( cameraIndex ) {\n\n\t\tvar camera;\n\t\tvar cameraDef = this.json.cameras[ cameraIndex ];\n\t\tvar params = cameraDef[ cameraDef.type ];\n\n\t\tif ( ! params ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing camera parameters.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( cameraDef.type === 'perspective' ) {\n\n\t\t\tcamera = new THREE.PerspectiveCamera( THREE.Math.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );\n\n\t\t} else if ( cameraDef.type === 'orthographic' ) {\n\n\t\t\tcamera = new THREE.OrthographicCamera( params.xmag / - 2, params.xmag / 2, params.ymag / 2, params.ymag / - 2, params.znear, params.zfar );\n\n\t\t}\n\n\t\tif ( cameraDef.name !== undefined ) camera.name = cameraDef.name;\n\n\t\tassignExtrasToUserData( camera, cameraDef );\n\n\t\treturn Promise.resolve( camera );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n\t * @param {number} skinIndex\n\t * @return {Promise<Object>}\n\t */\n\tGLTFParser.prototype.loadSkin = function ( skinIndex ) {\n\n\t\tvar skinDef = this.json.skins[ skinIndex ];\n\n\t\tvar skinEntry = { joints: skinDef.joints };\n\n\t\tif ( skinDef.inverseBindMatrices === undefined ) {\n\n\t\t\treturn Promise.resolve( skinEntry );\n\n\t\t}\n\n\t\treturn this.getDependency( 'accessor', skinDef.inverseBindMatrices ).then( function ( accessor ) {\n\n\t\t\tskinEntry.inverseBindMatrices = accessor;\n\n\t\t\treturn skinEntry;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n\t * @param {number} animationIndex\n\t * @return {Promise<THREE.AnimationClip>}\n\t */\n\tGLTFParser.prototype.loadAnimation = function ( animationIndex ) {\n\n\t\tvar json = this.json;\n\n\t\tvar animationDef = json.animations[ animationIndex ];\n\n\t\tvar pendingNodes = [];\n\t\tvar pendingInputAccessors = [];\n\t\tvar pendingOutputAccessors = [];\n\t\tvar pendingSamplers = [];\n\t\tvar pendingTargets = [];\n\n\t\tfor ( var i = 0, il = animationDef.channels.length; i < il; i ++ ) {\n\n\t\t\tvar channel = animationDef.channels[ i ];\n\t\t\tvar sampler = animationDef.samplers[ channel.sampler ];\n\t\t\tvar target = channel.target;\n\t\t\tvar name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\n\t\t\tvar input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;\n\t\t\tvar output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;\n\n\t\t\tpendingNodes.push( this.getDependency( 'node', name ) );\n\t\t\tpendingInputAccessors.push( this.getDependency( 'accessor', input ) );\n\t\t\tpendingOutputAccessors.push( this.getDependency( 'accessor', output ) );\n\t\t\tpendingSamplers.push( sampler );\n\t\t\tpendingTargets.push( target );\n\n\t\t}\n\n\t\treturn Promise.all( [\n\n\t\t\tPromise.all( pendingNodes ),\n\t\t\tPromise.all( pendingInputAccessors ),\n\t\t\tPromise.all( pendingOutputAccessors ),\n\t\t\tPromise.all( pendingSamplers ),\n\t\t\tPromise.all( pendingTargets )\n\n\t\t] ).then( function ( dependencies ) {\n\n\t\t\tvar nodes = dependencies[ 0 ];\n\t\t\tvar inputAccessors = dependencies[ 1 ];\n\t\t\tvar outputAccessors = dependencies[ 2 ];\n\t\t\tvar samplers = dependencies[ 3 ];\n\t\t\tvar targets = dependencies[ 4 ];\n\n\t\t\tvar tracks = [];\n\n\t\t\tfor ( var i = 0, il = nodes.length; i < il; i ++ ) {\n\n\t\t\t\tvar node = nodes[ i ];\n\t\t\t\tvar inputAccessor = inputAccessors[ i ];\n\t\t\t\tvar outputAccessor = outputAccessors[ i ];\n\t\t\t\tvar sampler = samplers[ i ];\n\t\t\t\tvar target = targets[ i ];\n\n\t\t\t\tif ( node === undefined ) continue;\n\n\t\t\t\tnode.updateMatrix();\n\t\t\t\tnode.matrixAutoUpdate = true;\n\n\t\t\t\tvar TypedKeyframeTrack;\n\n\t\t\t\tswitch ( PATH_PROPERTIES[ target.path ] ) {\n\n\t\t\t\t\tcase PATH_PROPERTIES.weights:\n\n\t\t\t\t\t\tTypedKeyframeTrack = THREE.NumberKeyframeTrack;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase PATH_PROPERTIES.rotation:\n\n\t\t\t\t\t\tTypedKeyframeTrack = THREE.QuaternionKeyframeTrack;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase PATH_PROPERTIES.position:\n\t\t\t\t\tcase PATH_PROPERTIES.scale:\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tTypedKeyframeTrack = THREE.VectorKeyframeTrack;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tvar targetName = node.name ? node.name : node.uuid;\n\n\t\t\t\tvar interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : THREE.InterpolateLinear;\n\n\t\t\t\tvar targetNames = [];\n\n\t\t\t\tif ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {\n\n\t\t\t\t\t// Node may be a THREE.Group (glTF mesh with several primitives) or a THREE.Mesh.\n\t\t\t\t\tnode.traverse( function ( object ) {\n\n\t\t\t\t\t\tif ( object.isMesh === true && object.morphTargetInfluences ) {\n\n\t\t\t\t\t\t\ttargetNames.push( object.name ? object.name : object.uuid );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetNames.push( targetName );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 0, jl = targetNames.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar track = new TypedKeyframeTrack(\n\t\t\t\t\t\ttargetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],\n\t\t\t\t\t\tinputAccessor.array,\n\t\t\t\t\t\toutputAccessor.array,\n\t\t\t\t\t\tinterpolation\n\t\t\t\t\t);\n\n\t\t\t\t\t// Override interpolation with custom factory method.\n\t\t\t\t\tif ( sampler.interpolation === 'CUBICSPLINE' ) {\n\n\t\t\t\t\t\ttrack.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {\n\n\t\t\t\t\t\t\t// A CUBICSPLINE keyframe in glTF has three output values for each input value,\n\t\t\t\t\t\t\t// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n\t\t\t\t\t\t\t// must be divided by three to get the interpolant's sampleSize argument.\n\n\t\t\t\t\t\t\treturn new GLTFCubicSplineInterpolant( this.times, this.values, this.getValueSize() / 3, result );\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n\t\t\t\t\t\ttrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttracks.push( track );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar name = animationDef.name !== undefined ? animationDef.name : 'animation_' + animationIndex;\n\n\t\t\treturn new THREE.AnimationClip( name, undefined, tracks );\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n\t * @param {number} nodeIndex\n\t * @return {Promise<THREE.Object3D>}\n\t */\n\tGLTFParser.prototype.loadNode = function ( nodeIndex ) {\n\n\t\tvar json = this.json;\n\t\tvar extensions = this.extensions;\n\t\tvar parser = this;\n\n\t\tvar meshReferences = json.meshReferences;\n\t\tvar meshUses = json.meshUses;\n\n\t\tvar nodeDef = json.nodes[ nodeIndex ];\n\n\t\treturn ( function () {\n\n\t\t\t// .isBone isn't in glTF spec. See .markDefs\n\t\t\tif ( nodeDef.isBone === true ) {\n\n\t\t\t\treturn Promise.resolve( new THREE.Bone() );\n\n\t\t\t} else if ( nodeDef.mesh !== undefined ) {\n\n\t\t\t\treturn parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {\n\n\t\t\t\t\tvar node;\n\n\t\t\t\t\tif ( meshReferences[ nodeDef.mesh ] > 1 ) {\n\n\t\t\t\t\t\tvar instanceNum = meshUses[ nodeDef.mesh ] ++;\n\n\t\t\t\t\t\tnode = mesh.clone();\n\t\t\t\t\t\tnode.name += '_instance_' + instanceNum;\n\n\t\t\t\t\t\t// onBeforeRender copy for Specular-Glossiness\n\t\t\t\t\t\tnode.onBeforeRender = mesh.onBeforeRender;\n\n\t\t\t\t\t\tfor ( var i = 0, il = node.children.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\tnode.children[ i ].name += '_instance_' + instanceNum;\n\t\t\t\t\t\t\tnode.children[ i ].onBeforeRender = mesh.children[ i ].onBeforeRender;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnode = mesh;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// if weights are provided on the node, override weights on the mesh.\n\t\t\t\t\tif ( nodeDef.weights !== undefined ) {\n\n\t\t\t\t\t\tnode.traverse( function ( o ) {\n\n\t\t\t\t\t\t\tif ( ! o.isMesh ) return;\n\n\t\t\t\t\t\t\tfor ( var i = 0, il = nodeDef.weights.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\t\to.morphTargetInfluences[ i ] = nodeDef.weights[ i ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn node;\n\n\t\t\t\t} );\n\n\t\t\t} else if ( nodeDef.camera !== undefined ) {\n\n\t\t\t\treturn parser.getDependency( 'camera', nodeDef.camera );\n\n\t\t\t} else if ( nodeDef.extensions\n\t\t\t\t&& nodeDef.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ]\n\t\t\t\t&& nodeDef.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ].light !== undefined ) {\n\n\t\t\t\treturn parser.getDependency( 'light', nodeDef.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ].light );\n\n\t\t\t} else {\n\n\t\t\t\treturn Promise.resolve( new THREE.Object3D() );\n\n\t\t\t}\n\n\t\t}() ).then( function ( node ) {\n\n\t\t\tif ( nodeDef.name !== undefined ) {\n\n\t\t\t\tnode.name = THREE.PropertyBinding.sanitizeNodeName( nodeDef.name );\n\n\t\t\t}\n\n\t\t\tassignExtrasToUserData( node, nodeDef );\n\n\t\t\tif ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );\n\n\t\t\tif ( nodeDef.matrix !== undefined ) {\n\n\t\t\t\tvar matrix = new THREE.Matrix4();\n\t\t\t\tmatrix.fromArray( nodeDef.matrix );\n\t\t\t\tnode.applyMatrix( matrix );\n\n\t\t\t} else {\n\n\t\t\t\tif ( nodeDef.translation !== undefined ) {\n\n\t\t\t\t\tnode.position.fromArray( nodeDef.translation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.rotation !== undefined ) {\n\n\t\t\t\t\tnode.quaternion.fromArray( nodeDef.rotation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.scale !== undefined ) {\n\n\t\t\t\t\tnode.scale.fromArray( nodeDef.scale );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n\t * @param {number} sceneIndex\n\t * @return {Promise<THREE.Scene>}\n\t */\n\tGLTFParser.prototype.loadScene = function () {\n\n\t\t// scene node hierachy builder\n\n\t\tfunction buildNodeHierachy( nodeId, parentObject, json, parser ) {\n\n\t\t\tvar nodeDef = json.nodes[ nodeId ];\n\n\t\t\treturn parser.getDependency( 'node', nodeId ).then( function ( node ) {\n\n\t\t\t\tif ( nodeDef.skin === undefined ) return node;\n\n\t\t\t\t// build skeleton here as well\n\n\t\t\t\tvar skinEntry;\n\n\t\t\t\treturn parser.getDependency( 'skin', nodeDef.skin ).then( function ( skin ) {\n\n\t\t\t\t\tskinEntry = skin;\n\n\t\t\t\t\tvar pendingJoints = [];\n\n\t\t\t\t\tfor ( var i = 0, il = skinEntry.joints.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tpendingJoints.push( parser.getDependency( 'node', skinEntry.joints[ i ] ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn Promise.all( pendingJoints );\n\n\t\t\t\t} ).then( function ( jointNodes ) {\n\n\t\t\t\t\tvar meshes = node.isGroup === true ? node.children : [ node ];\n\n\t\t\t\t\tfor ( var i = 0, il = meshes.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar mesh = meshes[ i ];\n\n\t\t\t\t\t\tvar bones = [];\n\t\t\t\t\t\tvar boneInverses = [];\n\n\t\t\t\t\t\tfor ( var j = 0, jl = jointNodes.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tvar jointNode = jointNodes[ j ];\n\n\t\t\t\t\t\t\tif ( jointNode ) {\n\n\t\t\t\t\t\t\t\tbones.push( jointNode );\n\n\t\t\t\t\t\t\t\tvar mat = new THREE.Matrix4();\n\n\t\t\t\t\t\t\t\tif ( skinEntry.inverseBindMatrices !== undefined ) {\n\n\t\t\t\t\t\t\t\t\tmat.fromArray( skinEntry.inverseBindMatrices.array, j * 16 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tboneInverses.push( mat );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Joint \"%s\" could not be found.', skinEntry.joints[ j ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmesh.bind( new THREE.Skeleton( bones, boneInverses ), mesh.matrixWorld );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn node;\n\n\t\t\t\t} );\n\n\t\t\t} ).then( function ( node ) {\n\n\t\t\t\t// build node hierachy\n\n\t\t\t\tparentObject.add( node );\n\n\t\t\t\tvar pending = [];\n\n\t\t\t\tif ( nodeDef.children ) {\n\n\t\t\t\t\tvar children = nodeDef.children;\n\n\t\t\t\t\tfor ( var i = 0, il = children.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar child = children[ i ];\n\t\t\t\t\t\tpending.push( buildNodeHierachy( child, node, json, parser ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn Promise.all( pending );\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn function loadScene( sceneIndex ) {\n\n\t\t\tvar json = this.json;\n\t\t\tvar extensions = this.extensions;\n\t\t\tvar sceneDef = this.json.scenes[ sceneIndex ];\n\t\t\tvar parser = this;\n\n\t\t\tvar scene = new THREE.Scene();\n\t\t\tif ( sceneDef.name !== undefined ) scene.name = sceneDef.name;\n\n\t\t\tassignExtrasToUserData( scene, sceneDef );\n\n\t\t\tif ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );\n\n\t\t\tvar nodeIds = sceneDef.nodes || [];\n\n\t\t\tvar pending = [];\n\n\t\t\tfor ( var i = 0, il = nodeIds.length; i < il; i ++ ) {\n\n\t\t\t\tpending.push( buildNodeHierachy( nodeIds[ i ], scene, json, parser ) );\n\n\t\t\t}\n\n\t\t\treturn Promise.all( pending ).then( function () {\n\n\t\t\t\treturn scene;\n\n\t\t\t} );\n\n\t\t};\n\n\t}();\n\n\treturn GLTFLoader;\n\n} )();\n","let THREE; let Ammo;\r\nlet scene; let camera; let renderer\r\nlet dynamicsWorld\r\nlet rigidBodies = []\r\nlet clock;\r\nlet transform;\r\nlet racket;\r\nlet p2p;\r\n\r\nfunction initPhysics () {\r\n  let config = new Ammo.btDefaultCollisionConfiguration()\r\n  let dispather = new Ammo.btCollisionDispatcher(config)\r\n  let broadphase = new Ammo.btDbvtBroadphase()\r\n  let solver = new Ammo.btSequentialImpulseConstraintSolver()\r\n  dynamicsWorld = new Ammo.btDiscreteDynamicsWorld(dispather, broadphase, solver, config)\r\n  dynamicsWorld.setGravity(new Ammo.btVector3(0, -10, 0))\r\n}\r\n\r\nfunction updatePhysics(deltaTime) {\r\n  if(p2p) {\r\n    p2p.enableFeedback(true)\r\n  }\r\n  dynamicsWorld.stepSimulation(deltaTime, 10)\r\n  // updateAction();\r\n  // Update rigid bodies\r\n  for ( let i = 0, il = rigidBodies.length; i < il; i ++ ) {\r\n\r\n    let objThree = rigidBodies[ i ];\r\n    let objPhys = objThree.userData.physicsBody;\r\n    let ms = objPhys.getMotionState();\r\n    if ( ms ) {\r\n      ms.getWorldTransform( transform );\r\n      let p = transform.getOrigin();\r\n      let q = transform.getRotation();\r\n      objThree.position.set( p.x(), p.y(), p.z() );\r\n      objThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );\r\n    }\r\n  }\r\n}\r\n\r\nfunction addRigidBody ({shape, mass = 0, localInertia = new Ammo.btVector3(0, 0, 0), bodyInfo, pos, quat}) {\r\n  pos = pos || this.position\r\n  quat = quat || this.quaternion\r\n  shape.setMargin(0.01)\r\n  let t = new Ammo.btTransform()\r\n  t.setIdentity()\r\n  t.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z))\r\n  t.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w))\r\n  let ms = new Ammo.btDefaultMotionState(t)\r\n  shape.calculateLocalInertia(mass, localInertia)\r\n  let rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, ms, shape, localInertia);\r\n  let body = new Ammo.btRigidBody(rbInfo);\r\n  if(!this.userData.physicsBodys) {\r\n    this.userData.physicsBodys = []\r\n  }\r\n  this.userData.physicsBody = body\r\n  this.userData.physicsBodys.push(body)\r\n  for(let i in bodyInfo) {\r\n    body['set' + i.charAt(0).toUpperCase() + i.substr(1)](bodyInfo[i])\r\n  }\r\n  dynamicsWorld.addRigidBody(body)\r\n  if(mass !== 0) // 重量为0不用动\r\n  rigidBodies.push(this)\r\n}\r\n\r\nfunction createHouse(length, width, height) {\r\n  let h = 0.1\r\n  let ground = new THREE.Mesh(new THREE.BoxGeometry(length, height, width ), new THREE.MeshPhongMaterial({ color: 0x646568, side: THREE.DoubleSide }))\r\n  ground.position.set(0, height / 2 - h, 0)\r\n  ground.castShadow = false\r\n  ground.receiveShadow = true\r\n  let bodyInfo= {\r\n    friction: 0.8,\r\n    restitution: 0.77\r\n  }\r\n  let mass = 0\r\n  let infos = [\r\n    {\r\n      shape: new Ammo.btBoxShape(new Ammo.btVector3(length / 2, h / 2, width / 2)),\r\n      pos: new THREE.Vector3(0, 0, 0)\r\n    },\r\n    {\r\n      shape: new Ammo.btBoxShape(new Ammo.btVector3(length / 2, h / 2, width / 2)),\r\n      pos: new THREE.Vector3(0,height,0)\r\n    },\r\n    {\r\n      shape: new Ammo.btBoxShape(new Ammo.btVector3(length / 2, height / 2, h / 2)),\r\n      pos: new THREE.Vector3(0,height / 2,-width / 2)\r\n    },\r\n    {\r\n      shape: new Ammo.btBoxShape(new Ammo.btVector3(length / 2, height / 2, h / 2)),\r\n      pos: new THREE.Vector3(0,height / 2,width / 2)\r\n    },\r\n    {\r\n      shape: new Ammo.btBoxShape(new Ammo.btVector3(h / 2, length / 2, width / 2)),\r\n      pos: new THREE.Vector3(length / 2,height / 2,0)\r\n    },\r\n    {\r\n      shape: new Ammo.btBoxShape(new Ammo.btVector3(h / 2, length / 2, width / 2)),\r\n      pos: new THREE.Vector3(-length / 2,height / 2,0)\r\n\r\n    }\r\n  ]\r\n  for( let i in infos) {\r\n    ground.addRigidBody({\r\n      pos:infos[i].pos,\r\n      shape: infos[i].shape,\r\n      mass,\r\n      bodyInfo,\r\n    })\r\n  }\r\n  scene.add(ground)\r\n}\r\n\r\nfunction createObjects() {\r\n  createHouse(800, 600, 300)\r\n\r\n  let pLight = new THREE.PointLight(0x808080, 1, 3000, 0.9)\r\n  pLight.position.set(10, 200, 10)\r\n  pLight.castShadow = true\r\n  let p2 = pLight.clone()\r\n  p2.position.set(-20, 180, -20)\r\n  scene.add(pLight)\r\n  scene.add(p2)\r\n\r\n  let loader = new THREE.GLTFLoader()\r\n  let tableHeight = 76.25\r\n  loader.load(require('./assets/pingpong.gltf'), function (obj) {\r\n    let table = obj.scene.children[0]\r\n    table.position.y = tableHeight / 2\r\n    table.addRigidBody({\r\n      shape: new Ammo.btBoxShape(new Ammo.btVector3(274 / 2, tableHeight / 2, 152.5 / 2)),\r\n      mass: 0,\r\n      bodyInfo: {\r\n        friction: 0.5,\r\n        restitution: 0.77\r\n      }\r\n    })\r\n    table.castShadow = true\r\n    table.receiveShadow = true\r\n    scene.add(table)\r\n  }, function (xhr) {\r\n    console.log(xhr)\r\n  }, function (err) {\r\n    console.error(err)\r\n  })\r\n\r\n  loader.load(require('./assets/racket.gltf'), function (obj) {\r\n    racket = obj.scene.children[0]\r\n    racket.position.y = (tableHeight + 200) / 2\r\n    racket.addRigidBody({\r\n      shape: new Ammo.btBoxShape(new Ammo.btVector3(1.6 / 2, 24.7 / 2, 15 / 2)),\r\n      mass: 10,\r\n      bodyInfo: {\r\n        friction: 0.5,\r\n        restitution: 0.9\r\n      }\r\n    })\r\n    racket.castShadow = true\r\n    racket.receiveShadow = true\r\n    scene.add(racket)\r\n  }, function (xhr) {\r\n    console.log(xhr)\r\n  }, function (err) {\r\n    console.error(err)\r\n  })\r\n\r\n  const radius = 2;\r\n  let ball = new THREE.Mesh(\r\n    new THREE.SphereGeometry(radius,10,10),\r\n    new THREE.MeshLambertMaterial({color: 0xffaa00})\r\n  )\r\n  ball.castShadow = true\r\n  ball.receiveShadow = true\r\n  ball.position.set(30, tableHeight + 50, 30)\r\n  scene.add(ball)\r\n  let ballShape = new Ammo.btSphereShape(radius)\r\n  ball.addRigidBody({\r\n    shape: ballShape,\r\n    mass: 0.26,\r\n    localInertia: new Ammo.btVector3(0, 0, 0),\r\n    bodyInfo: {\r\n      friction: 0.5,\r\n      restitution: 1,\r\n      rollingFriction: 1\r\n    }\r\n  })\r\n}\r\n\r\nfunction initWorld () {\r\n  window.scene = scene = new THREE.Scene({ antialias: true })\r\n  scene.background = new THREE.Color(0xbfd1e5)\r\n  let light = new THREE.AmbientLight(0x303030)\r\n  scene.add(light)\r\n\r\n  camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 20000)\r\n  camera.position.set(150, 100, 80)\r\n  camera.lookAt(0, 76, 0)\r\n\r\n  renderer = new THREE.WebGLRenderer()\r\n  renderer.setPixelRatio(window.devicePixelRatio)\r\n  renderer.setSize(window.innerWidth, window.innerHeight)\r\n  renderer.shadowMap.enabled = true\r\n  renderer.render(scene, camera)\r\n\r\n  let controls = new THREE.OrbitControls(camera)\r\n  controls.target.set(0, 2, 0)\r\n  controls.update()\r\n\r\n  document.getElementById('container').appendChild(renderer.domElement)\r\n  window.addEventListener('keydown', function (e) {\r\n    // 这里bullet示例源码里头移动物体是通过修改点对点约束做到移动的\r\n    let bd = racket.userData.physicsBody\r\n    let origin = bd.getWorldTransform().getOrigin();\r\n    let pt = new THREE.Object3D()\r\n    pt.position.set(origin.x(),origin.y() + 0.01,origin.z())\r\n    pt.addRigidBody({shape: new Ammo.btBoxShape(new Ammo.btVector3(1,1,1))})\r\n    switch (e.keyCode) {\r\n      case 65: // a\r\n        console.log(bd,dynamicsWorld, p2p)\r\n        dynamicsWorld.removeConstraint(p2p)\r\n        p2p = new Ammo.btPoint2PointConstraint( pt.userData.physicsBody, bd,  new Ammo.btVector3(origin.x(),origin.y() + 0.01,origin.z()), new Ammo.btVector3(origin.x(),origin.y(),origin.z()) );\r\n        dynamicsWorld.addConstraint( p2p, true );\r\n\r\n        break;\r\n      case 83: // s\r\n\r\n        break;\r\n      case 68: // d\r\n\r\n        break;\r\n      case 87: // w\r\n\r\n        break;\r\n    }\r\n  })\r\n}\r\n\r\nlet stopFlag = false\r\nfunction animate () {\r\n  if(!stopFlag) {\r\n    updatePhysics(clock.getDelta() * 1000)\r\n    renderer.render(scene, camera)\r\n    requestAnimationFrame(animate)\r\n  }\r\n}\r\n\r\nlet flagArr = [false, false]\r\n\r\nfunction index () {\r\n  let delay = 100\r\n  function init() {\r\n    if(flagArr.every(value => value)) {\r\n      initPhysics()\r\n      initWorld()\r\n      createObjects()\r\n      animate()\r\n    } else {\r\n      setTimeout(init, delay)\r\n    }\r\n  }\r\n  if(!scene) {\r\n    setTimeout(init, delay)\r\n  } else {\r\n    document.getElementById('container').appendChild(renderer.domElement)\r\n  }\r\n}\r\n\r\nlet loaded = false\r\nindex.beforeEnter = function() {\r\n  if(!loaded) {\r\n    import('ammo.js').then(value => {\r\n      Ammo = value\r\n      flagArr[0] = true\r\n      transform = new Ammo.btTransform() // 暂存物体位置数据\r\n    })\r\n    import('three').then(value => {\r\n      window.THREE = THREE = value\r\n      flagArr[1] = true\r\n      require('three/examples/js/controls/OrbitControls')\r\n      require('three/examples/js/loaders/GLTFLoader')\r\n      THREE.Object3D.prototype.addRigidBody = addRigidBody;\r\n      clock = new THREE.Clock()\r\n    })\r\n  }\r\n  loaded = true\r\n  if(stopFlag) {\r\n    stopFlag = false\r\n    animate()\r\n  }\r\n}\r\n\r\nindex.beforeLeave = function() {\r\n  stopFlag = true\r\n}\r\n\r\nmodule.exports = index\r\n","module.exports = function loadJSBundle(bundle) {\n  return new Promise(function (resolve, reject) {\n    var script = document.createElement('script');\n    script.async = true;\n    script.type = 'text/javascript';\n    script.charset = 'utf-8';\n    script.src = bundle;\n    script.onerror = function (e) {\n      script.onerror = script.onload = null;\n      reject(e);\n    };\n\n    script.onload = function () {\n      script.onerror = script.onload = null;\n      resolve();\n    };\n\n    document.getElementsByTagName('head')[0].appendChild(script);\n  });\n};\n"]}